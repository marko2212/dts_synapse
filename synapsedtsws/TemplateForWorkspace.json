{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"workspaceName": {
			"type": "string",
			"metadata": "Workspace name",
			"defaultValue": "synapsedtsws"
		},
		"ls_asql_db_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'ls_asql_db'"
		},
		"ls_dl_asa_dts_accountKey": {
			"type": "secureString",
			"metadata": "Secure string for 'accountKey' of 'ls_dl_asa_dts'"
		},
		"synapsedtsws-WorkspaceDefaultSqlServer_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'synapsedtsws-WorkspaceDefaultSqlServer'"
		},
		"ls_dl_asa_dts_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://dlsynapsedts.dfs.core.windows.net"
		},
		"synapsedtsws-WorkspaceDefaultStorage_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://dlsynapsedts.dfs.core.windows.net"
		}
	},
	"variables": {
		"workspaceId": "[concat('Microsoft.Synapse/workspaces/', parameters('workspaceName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('workspaceName'), '/pip_copy_all_dl_sql')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Copy mat_csv_to_sql",
						"description": "",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Copy pos_xlsx_to_sql",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"preCopyScript": "Truncate table stg.materijal",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "SIFRA_MATERIJALA",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SIFRA_MATERIJALA",
											"type": "Int32",
											"physicalType": "int"
										}
									},
									{
										"source": {
											"name": "BROJ_KOMADA_U_KART",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BROJ_KOMADA_U_KART",
											"type": "Int32",
											"physicalType": "int"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_dl_mat_csv",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_sql_mat",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Copy odel_csv_to_sql",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Copy mat_csv_to_sql",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"preCopyScript": "TRUNCATE TABLE stg.odeljak",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "Odeljak",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ODELJAK",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "Brend",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BREND",
											"type": "String",
											"physicalType": "varchar"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_dl_odelj_csv",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_sql_odelj",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Copy pos_xlsx_to_sql",
						"description": "",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Copy sap_csv_sql",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "ExcelSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFileName": "*20*",
									"enablePartitionDiscovery": false
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"preCopyScript": "TRUNCATE TABLE stg.evidencijaPOS",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "datum",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DATUM",
											"type": "DateTime",
											"physicalType": "date"
										}
									},
									{
										"source": {
											"name": "brend",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BREND_ORIG",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "Å¡ifra brenda",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SIFRA_BRENDA",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "vrsta dokumenta",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "VRSTA_DOKUMENTA",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "broj stavki",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BROJ_STAVKI",
											"type": "Int32",
											"physicalType": "int"
										}
									},
									{
										"source": {
											"name": "broj paleta",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BROJ_PALETA",
											"type": "Int32",
											"physicalType": "int"
										}
									},
									{
										"source": {
											"name": "Broj kartona povrat",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BROJ_KARTONA_POVRAT",
											"type": "Int32",
											"physicalType": "int"
										}
									},
									{
										"source": {
											"name": "Broj komada povrata",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BROJ_KOMADA_POVRAT",
											"type": "Int32",
											"physicalType": "int"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_dl_pos_xlsx",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_sql_pos",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Copy sap_csv_sql",
						"description": "",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFileName": "DMD_20*",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"preCopyScript": "TRUNCATE TABLE stg.sap",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "WBSTK",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "WBSTK",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "PRIMALAC_ROBE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PRIMALAC_ROBE",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "TIP_ISPORUKE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "TIP_ISPORUKE",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "STVARNI_DATUM_ISPORUKE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "STVARNI_DATUM_ISPORUKE",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "MATERIJAL",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MATERIJAL",
											"type": "Int32",
											"physicalType": "int"
										}
									},
									{
										"source": {
											"name": "KOLICINA",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "KOLICINA",
											"type": "Double",
											"physicalType": "float"
										}
									},
									{
										"source": {
											"name": "SKLADISNA_LOKACIJA",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SKLADISNA_LOKACIJA",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "POGON",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "POGON",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "ODELJAK",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ODELJAK",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "SIFRA_RAZLOGA_POVRATA",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SIFRA_RAZLOGA_POVRATA",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "OPIS_RAZLOGA_POVRATA",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OPIS_RAZLOGA_POVRATA",
											"type": "String",
											"physicalType": "varchar"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_dl_sap_csv",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_sql_stg_sap",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": [],
				"lastPublishTime": "2022-05-12T12:25:59Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_dl_mat_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_sql_mat')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_odelj_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_sql_odelj')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_pos_xlsx')]",
				"[concat(variables('workspaceId'), '/datasets/ds_sql_pos')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_sap_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_sql_stg_sap')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_copy_mat_csv_to_sql')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Copy mat_csv_to_sql",
						"description": "",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"preCopyScript": "Truncate table stg.materijal",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "SIFRA_MATERIJALA",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SIFRA_MATERIJALA",
											"type": "Int32",
											"physicalType": "int"
										}
									},
									{
										"source": {
											"name": "BROJ_KOMADA_U_KART",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BROJ_KOMADA_U_KART",
											"type": "Int32",
											"physicalType": "int"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_dl_mat_csv",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_sql_mat",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Pojedinacno stg"
				},
				"annotations": [],
				"lastPublishTime": "2022-05-10T14:47:11Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_dl_mat_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_sql_mat')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_copy_odelj_csv_to_sql')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Copy odel_csv_to_sql",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"preCopyScript": "TRUNCATE TABLE stg.odeljak",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "Odeljak",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ODELJAK",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "Brend",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BREND",
											"type": "String",
											"physicalType": "varchar"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_dl_odelj_csv",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_sql_odelj",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Pojedinacno stg"
				},
				"annotations": [],
				"lastPublishTime": "2022-05-10T14:46:55Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_dl_odelj_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_sql_odelj')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_copy_pos_xlsx_to_sql')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Copy pos_xlsx_to_sql",
						"description": "",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "ExcelSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFileName": "*20*",
									"enablePartitionDiscovery": false
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"preCopyScript": "TRUNCATE TABLE stg.evidencijaPOS",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "datum",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DATUM",
											"type": "DateTime",
											"physicalType": "date"
										}
									},
									{
										"source": {
											"name": "brend",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BREND_ORIG",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "Å¡ifra brenda",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SIFRA_BRENDA",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "vrsta dokumenta",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "VRSTA_DOKUMENTA",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "broj stavki",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BROJ_STAVKI",
											"type": "Int32",
											"physicalType": "int"
										}
									},
									{
										"source": {
											"name": "broj paleta",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BROJ_PALETA",
											"type": "Int32",
											"physicalType": "int"
										}
									},
									{
										"source": {
											"name": "Broj kartona povrat",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BROJ_KARTONA_POVRAT",
											"type": "Int32",
											"physicalType": "int"
										}
									},
									{
										"source": {
											"name": "Broj komada povrata",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BROJ_KOMADA_POVRAT",
											"type": "Int32",
											"physicalType": "int"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_dl_pos_xlsx",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_sql_pos",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Pojedinacno stg"
				},
				"annotations": [],
				"lastPublishTime": "2022-05-10T14:46:51Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_dl_pos_xlsx')]",
				"[concat(variables('workspaceId'), '/datasets/ds_sql_pos')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_copy_sap_csv_to_sql')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Copy sap_csv_sql",
						"description": "",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFileName": "DMD_20*",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"preCopyScript": "TRUNCATE TABLE stg.sap",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "WBSTK",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "WBSTK",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "PRIMALAC_ROBE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PRIMALAC_ROBE",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "TIP_ISPORUKE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "TIP_ISPORUKE",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "STVARNI_DATUM_ISPORUKE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "STVARNI_DATUM_ISPORUKE",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "MATERIJAL",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MATERIJAL",
											"type": "Int32",
											"physicalType": "int"
										}
									},
									{
										"source": {
											"name": "KOLICINA",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "KOLICINA",
											"type": "Double",
											"physicalType": "float"
										}
									},
									{
										"source": {
											"name": "SKLADISNA_LOKACIJA",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SKLADISNA_LOKACIJA",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "POGON",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "POGON",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "ODELJAK",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ODELJAK",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "SIFRA_RAZLOGA_POVRATA",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SIFRA_RAZLOGA_POVRATA",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "OPIS_RAZLOGA_POVRATA",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OPIS_RAZLOGA_POVRATA",
											"type": "String",
											"physicalType": "varchar"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_dl_sap_csv",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_sql_stg_sap",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Pojedinacno stg"
				},
				"annotations": [],
				"lastPublishTime": "2022-05-10T14:46:44Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_dl_sap_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_sql_stg_sap')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_ml')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Notebook ML Model 2",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Notebook ML Model",
								"type": "NotebookReference"
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "SparkSmall",
								"type": "BigDataPoolReference"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": [],
				"lastPublishTime": "2022-05-12T12:06:32Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/Notebook ML Model')]",
				"[concat(variables('workspaceId'), '/bigDataPools/SparkSmall')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_povrat_brend')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Stored procedure povrat brend",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[dbo].[PovratBrend]"
						},
						"linkedServiceName": {
							"referenceName": "ls_asql_db",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "pojedinacno transf"
				},
				"annotations": [],
				"lastPublishTime": "2022-05-12T12:06:04Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_asql_db')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_sp_komis')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "pip_sp_komis",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[dbo].[Komision]"
						},
						"linkedServiceName": {
							"referenceName": "ls_asql_db",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "pojedinacno transf"
				},
				"annotations": [],
				"lastPublishTime": "2022-05-12T12:05:20Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_asql_db')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_sp_komis_brend')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Stored procedure komis_brend",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[dbo].[KomisionBrend]"
						},
						"linkedServiceName": {
							"referenceName": "ls_asql_db",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "pojedinacno transf"
				},
				"annotations": [],
				"lastPublishTime": "2022-05-12T12:05:24Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_asql_db')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_sp_povrat')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Stored procedure Povrat",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[dbo].[Povrat]"
						},
						"linkedServiceName": {
							"referenceName": "ls_asql_db",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "pojedinacno transf"
				},
				"annotations": [],
				"lastPublishTime": "2022-05-12T12:05:17Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_asql_db')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_transf_all')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Stored procedure povrat brend",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "pip_sp_komis",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[dbo].[PovratBrend]"
						},
						"linkedServiceName": {
							"referenceName": "ls_asql_db",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "pip_sp_komis",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "Stored procedure komis_brend",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[dbo].[Komision]"
						},
						"linkedServiceName": {
							"referenceName": "ls_asql_db",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "Stored procedure komis_brend",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[dbo].[KomisionBrend]"
						},
						"linkedServiceName": {
							"referenceName": "ls_asql_db",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "Stored procedure Povrat",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "Stored procedure povrat brend",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[dbo].[Povrat]"
						},
						"linkedServiceName": {
							"referenceName": "ls_asql_db",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": [],
				"lastPublishTime": "2022-05-12T12:06:15Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_asql_db')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pl_df_marko')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_marko",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"sourceSAP": {},
									"sourceMat": {},
									"sourceBrend": {},
									"sinkKomis": {},
									"sinkPovrat": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "pojedinacno transf"
				},
				"annotations": [],
				"lastPublishTime": "2022-05-12T12:05:12Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/df_marko')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_dl_mat_csv')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_asa_dts",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "Mat_fix.csv",
						"folderPath": "dmd/Materijal",
						"fileSystem": "row"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "SIFRA_MATERIJALA",
						"type": "String"
					},
					{
						"name": "BROJ_KOMADA_U_KART",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_asa_dts')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_dl_mat_xls')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_asa_dts",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "archive"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"sheetName": "Sheet1",
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "Mat_fix.xlsx",
						"folderPath": "dmd/Materijali",
						"fileSystem": "row"
					},
					"firstRowAsHeader": true
				},
				"schema": [
					{
						"name": "Sifra_materijala",
						"type": "String"
					},
					{
						"name": "Broj_komada_u_kart",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_asa_dts')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_dl_odelj_csv')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_asa_dts",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "Odeljak_fix.csv",
						"folderPath": "dmd/Odeljak",
						"fileSystem": "row"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Odeljak",
						"type": "String"
					},
					{
						"name": "Brend",
						"type": "String"
					},
					{
						"name": "Opis",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_asa_dts')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_dl_odeljak_csv')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_asa_dts",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "Odeljak.csv",
						"folderPath": "dmd/SAP",
						"fileSystem": "row"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Odeljak",
						"type": "String"
					},
					{
						"name": "BRAND",
						"type": "String"
					},
					{
						"name": "Opis",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_asa_dts')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_dl_pos_xlsx')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_asa_dts",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"sheetName": "baza uraÄenih naloga",
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "evidencija_uraÄenih_naloga_POS_2020.xlsx",
						"folderPath": "dmd/POS",
						"fileSystem": "row"
					},
					"range": "A9:K1000000",
					"firstRowAsHeader": true
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_asa_dts')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_dl_processed_dmd_sink_csv')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_asa_dts",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "archive"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "holder.csv",
						"folderPath": "dmd/SAP",
						"fileSystem": "processed"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_asa_dts')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_dl_sap_csv')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_asa_dts",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "DMD_2020.csv",
						"folderPath": "dmd/SAP",
						"fileSystem": "row"
					},
					"columnDelimiter": "|",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_asa_dts')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_dl_to_sql_2')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_asa_dts",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "DMD_2020.csv",
						"folderPath": "dmd/SAP",
						"fileSystem": "row"
					},
					"columnDelimiter": "|",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "DOKUMENT_ISPORUKE|STAVKA|OBLAST_PRODAJE|WBSTK|PRIMALAC_ROBE|TIP_ISPORUKE|TIP_PROD_DOK|DATUM_ISPORUKE|DOBAVLJAC|PLANIRANI_DATUM_ISPORUKE|STVARNI_DATUM_ISPORUKE|MATERIJAL|KOLICINA|SKLADISNA_LOKACIJA|POGON|ODELJAK|SIFRA_RAZLOGA_POVRATA|OPIS_RAZLOGA_POVRATA",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_asa_dts')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_sql_mat')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_asql_db",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "SIFRA_MATERIJALA",
						"type": "int",
						"precision": 10
					},
					{
						"name": "BROJ_KOMADA_U_KART",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "stg",
					"table": "materijal"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_asql_db')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_sql_odelj')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_asql_db",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "ODELJAK",
						"type": "int",
						"precision": 10
					},
					{
						"name": "BREND",
						"type": "varchar"
					}
				],
				"typeProperties": {
					"schema": "stg",
					"table": "odeljak"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_asql_db')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_sql_pos')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_asql_db",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "DATUM",
						"type": "date"
					},
					{
						"name": "BREND_ORIG",
						"type": "varchar"
					},
					{
						"name": "SIFRA_BRENDA",
						"type": "varchar"
					},
					{
						"name": "VRSTA_DOKUMENTA",
						"type": "varchar"
					},
					{
						"name": "BROJ_STAVKI",
						"type": "int",
						"precision": 10
					},
					{
						"name": "BROJ_PALETA",
						"type": "int",
						"precision": 10
					},
					{
						"name": "BROJ_KARTONA_POVRAT",
						"type": "int",
						"precision": 10
					},
					{
						"name": "BROJ_KOMADA_POVRAT",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "stg",
					"table": "evidencijaPOS"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_asql_db')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_sql_stg_sap')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_asql_db",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [],
				"typeProperties": {
					"schema": "stg",
					"table": "sap"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_asql_db')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_asql_db')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureSqlDatabase",
				"typeProperties": {
					"connectionString": "[parameters('ls_asql_db_connectionString')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_dl_asa_dts')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('ls_dl_asa_dts_properties_typeProperties_url')]",
					"accountKey": {
						"type": "SecureString",
						"value": "[parameters('ls_dl_asa_dts_accountKey')]"
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/synapsedtsws-WorkspaceDefaultSqlServer')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"parameters": {
					"DBName": {
						"type": "String"
					}
				},
				"annotations": [],
				"type": "AzureSqlDW",
				"typeProperties": {
					"connectionString": "[parameters('synapsedtsws-WorkspaceDefaultSqlServer_connectionString')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/synapsedtsws-WorkspaceDefaultStorage')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('synapsedtsws-WorkspaceDefaultStorage_properties_typeProperties_url')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/trg_copy_dl_to_sql')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Copy all from datalake to SQL stg tables",
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "pip_copy_all_dl_sql",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2022-05-10T18:49:00",
						"timeZone": "Central Europe Standard Time",
						"schedule": {
							"minutes": [
								0
							],
							"hours": [
								7
							]
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/pip_copy_all_dl_sql')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/trg_ml')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "pip_ml",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2022-05-12T12:35:00Z",
						"timeZone": "UTC",
						"schedule": {
							"minutes": [
								0
							],
							"hours": [
								9
							]
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/pip_ml')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/trg_transf')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "pip_transf_all",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2022-05-12T12:31:00Z",
						"timeZone": "UTC",
						"schedule": {
							"minutes": [
								0
							],
							"hours": [
								8
							]
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/pip_transf_all')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AutoResolveIntegrationRuntime')]",
			"type": "Microsoft.Synapse/workspaces/integrationRuntimes",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "Managed",
				"typeProperties": {
					"computeProperties": {
						"location": "AutoResolve",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 8,
							"timeToLive": 0
						}
					}
				},
				"managedVirtualNetwork": {
					"type": "ManagedVirtualNetworkReference",
					"referenceName": "default"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/managedVirtualNetworks/default')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/df_marko')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_dl_sap_csv",
								"type": "DatasetReference"
							},
							"name": "sourceSAP"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_mat_xls",
								"type": "DatasetReference"
							},
							"name": "sourceMat"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_odeljak_csv",
								"type": "DatasetReference"
							},
							"name": "sourceBrend"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_dl_processed_dmd_sink_csv",
								"type": "DatasetReference"
							},
							"name": "sinkKomis"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_processed_dmd_sink_csv",
								"type": "DatasetReference"
							},
							"name": "sinkPovrat"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_processed_dmd_sink_csv",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "selectRename"
						},
						{
							"name": "filterPogonStat"
						},
						{
							"name": "split1"
						},
						{
							"name": "joinMat"
						},
						{
							"name": "select4Col"
						},
						{
							"name": "derivedKarton"
						},
						{
							"name": "select3Col"
						},
						{
							"name": "aggregateCount"
						},
						{
							"name": "sortDatum"
						},
						{
							"name": "filterRazlogPovrata"
						},
						{
							"name": "aggregateSum"
						},
						{
							"name": "sortDat"
						},
						{
							"name": "derivedDate"
						},
						{
							"name": "filterSkladKolic"
						},
						{
							"name": "join1"
						},
						{
							"name": "selectRenBrend"
						}
					],
					"scriptLines": [
						"source(output(",
						"          DOKUMENT_ISPORUKE as integer,",
						"          STAVKA as integer,",
						"          OBLAST_PRODAJE as string,",
						"          WBSTK as string,",
						"          PRIMALAC_ROBE as long,",
						"          TIP_ISPORUKE as string,",
						"          TIP_PROD_DOK as string,",
						"          DATUM_ISPORUKE as date 'yyyyMMdd',",
						"          DOBAVLJAC as string,",
						"          PLANIRANI_DATUM_ISPORUKE as date 'yyyyMMdd',",
						"          STVARNI_DATUM_ISPORUKE as date 'yyyyMMdd',",
						"          MATERIJAL as integer,",
						"          KOLICINA as short,",
						"          SKLADISNA_LOKACIJA as string,",
						"          POGON as string,",
						"          ODELJAK as string,",
						"          SIFRA_RAZLOGA_POVRATA as string,",
						"          OPIS_RAZLOGA_POVRATA as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> sourceSAP",
						"source(output(",
						"          Sifra_materijala as integer,",
						"          Broj_komada_u_kart as short",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> sourceMat",
						"source(output(",
						"          Odeljak as string,",
						"          BRAND as short,",
						"          Opis as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> sourceBrend",
						"filterPogonStat select(mapColumn(",
						"          PRIMALAC_ROBE,",
						"          TIP_ISPORUKE,",
						"          DATUM = STVARNI_DATUM_ISPORUKE,",
						"          MATERIJAL,",
						"          KOLICINA,",
						"          SKLADISNA_LOKACIJA,",
						"          ODELJAK,",
						"          SIFRA_RAZLOGA_POVRATA,",
						"          OPIS_RAZLOGA_POVRATA",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRename",
						"sourceSAP filter(POGON=='MD10' && WBSTK == 'C'",
						"&& in(['10PZ', '40PZ', '90PZ','10CA', '10NI', 'PRM1', 'PRV1'], SKLADISNA_LOKACIJA)",
						"&& in(['ZLR', 'ZLX', 'LB', 'ZLA', 'ZLE', 'ZLO', 'ZLF', 'RL', 'Y73', 'YO3', 'YU3', 'YZO1', 'YZU1'], TIP_ISPORUKE)) ~> filterPogonStat",
						"join1 split(TIP_ISPORUKE=='ZLX' || TIP_ISPORUKE =='ZLR',",
						"     disjoint: false) ~> split1@(Povrat, Komision)",
						"select4Col, sourceMat join(MATERIJAL == Sifra_materijala,",
						"     joinType:'inner',",
						"     broadcast: 'auto')~> joinMat",
						"filterRazlogPovrata select(mapColumn(",
						"          DATUM,",
						"          MATERIJAL,",
						"          KOLICINA,",
						"          ODELJAK,",
						"          SIFRA_RAZLOGA_POVRATA,",
						"          OPIS_RAZLOGA_POVRATA",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4Col",
						"joinMat derive(Kartona = round(KOLICINA /Broj_komada_u_kart, 0, 2),",
						"          Komada_ostalo = ( KOLICINA /Broj_komada_u_kart - round(KOLICINA /Broj_komada_u_kart, 0, 2) ) * Broj_komada_u_kart) ~> derivedKarton",
						"filterSkladKolic select(mapColumn(",
						"          PRIMALAC_ROBE,",
						"          DATUM,",
						"          ODELJAK,",
						"          KOLICINA",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3Col",
						"select3Col aggregate(groupBy(DATUM),",
						"     Stavka_na_komisionom_nalogu = count(KOLICINA),",
						"          Komisioni_nalog = countDistinct(PRIMALAC_ROBE)) ~> aggregateCount",
						"aggregateCount sort(asc(DATUM, true)) ~> sortDatum",
						"split1@Povrat filter(not (in(['P03', 'N03', 'N05', 'N05'], SIFRA_RAZLOGA_POVRATA))) ~> filterRazlogPovrata",
						"derivedKarton aggregate(groupBy(DATUM),",
						"     Povrat_robe_po_kartonu = sum(Kartona),",
						"          Stavka_na_komisionom_nalogu = sum(Komada_ostalo)) ~> aggregateSum",
						"aggregateSum sort(asc(DATUM, true)) ~> sortDat",
						"sortDatum derive(day_of_week = dayOfWeek(DATUM),",
						"          day_of_month = dayOfMonth(DATUM),",
						"          day_of_year = dayOfYear(DATUM),",
						"          week_of_year = weekOfYear(DATUM),",
						"          year = year(DATUM)) ~> derivedDate",
						"split1@Komision filter(in(['10PZ', '40PZ', '90PZ'], SKLADISNA_LOKACIJA) ",
						"&& KOLICINA != 0 ",
						"&& in(['LB', 'ZLA', 'ZLE', 'ZLO', 'ZLF', 'RL', 'Y73', 'YO3', 'YU3', 'YZO1', 'YZU1'], TIP_ISPORUKE)) ~> filterSkladKolic",
						"selectRename, selectRenBrend join(selectRename@ODELJAK == selectRenBrend@Odeljak,",
						"     joinType:'left',",
						"     broadcast: 'auto')~> join1",
						"sourceBrend select(mapColumn(",
						"          Odeljak,",
						"          Brend = Opis",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRenBrend",
						"derivedDate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['komisionAgg.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sinkKomis",
						"sortDat sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['povratAgg.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sinkPovrat",
						"filterSkladKolic sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['test2preporc.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_dl_sap_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_mat_xls')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_odeljak_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_processed_dmd_sink_csv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/df_marko_copy1')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_dl_sap_csv",
								"type": "DatasetReference"
							},
							"name": "sourceSAP"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_mat_xls",
								"type": "DatasetReference"
							},
							"name": "sourceMat"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_odeljak_csv",
								"type": "DatasetReference"
							},
							"name": "sourceBrend"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_sap_csv",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_dl_processed_dmd_sink_csv",
								"type": "DatasetReference"
							},
							"name": "sinkKomis"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_processed_dmd_sink_csv",
								"type": "DatasetReference"
							},
							"name": "sinkPovrat"
						}
					],
					"transformations": [
						{
							"name": "selectRename"
						},
						{
							"name": "filterPogonStat"
						},
						{
							"name": "split1"
						},
						{
							"name": "joinMat"
						},
						{
							"name": "select4Col"
						},
						{
							"name": "derivedKarton"
						},
						{
							"name": "select3Col"
						},
						{
							"name": "aggregateCount"
						},
						{
							"name": "sortDatum"
						},
						{
							"name": "filterRazlogPovrata"
						},
						{
							"name": "aggregateSum"
						},
						{
							"name": "sortDat"
						},
						{
							"name": "derivedDate"
						},
						{
							"name": "filterSkladKolic"
						},
						{
							"name": "join1"
						},
						{
							"name": "selectRenBrend"
						}
					],
					"scriptLines": [
						"source(output(",
						"          DOKUMENT_ISPORUKE as integer,",
						"          STAVKA as integer,",
						"          OBLAST_PRODAJE as string,",
						"          WBSTK as string,",
						"          PRIMALAC_ROBE as long,",
						"          TIP_ISPORUKE as string,",
						"          TIP_PROD_DOK as string,",
						"          DATUM_ISPORUKE as date 'yyyyMMdd',",
						"          DOBAVLJAC as string,",
						"          PLANIRANI_DATUM_ISPORUKE as date 'yyyyMMdd',",
						"          STVARNI_DATUM_ISPORUKE as date 'yyyyMMdd',",
						"          MATERIJAL as integer,",
						"          KOLICINA as short,",
						"          SKLADISNA_LOKACIJA as string,",
						"          POGON as string,",
						"          ODELJAK as string,",
						"          SIFRA_RAZLOGA_POVRATA as string,",
						"          OPIS_RAZLOGA_POVRATA as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> sourceSAP",
						"source(output(",
						"          Sifra_materijala as integer,",
						"          Broj_komada_u_kart as short",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> sourceMat",
						"source(output(",
						"          Odeljak as string,",
						"          BRAND as short,",
						"          Opis as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> sourceBrend",
						"source(output(",
						"          DOKUMENT_ISPORUKE as string,",
						"          STAVKA as string,",
						"          OBLAST_PRODAJE as string,",
						"          WBSTK as string,",
						"          PRIMALAC_ROBE as string,",
						"          TIP_ISPORUKE as string,",
						"          TIP_PROD_DOK as string,",
						"          DATUM_ISPORUKE as string,",
						"          DOBAVLJAC as string,",
						"          PLANIRANI_DATUM_ISPORUKE as string,",
						"          STVARNI_DATUM_ISPORUKE as string,",
						"          MATERIJAL as string,",
						"          KOLICINA as string,",
						"          SKLADISNA_LOKACIJA as string,",
						"          POGON as string,",
						"          ODELJAK as string,",
						"          SIFRA_RAZLOGA_POVRATA as string,",
						"          OPIS_RAZLOGA_POVRATA as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     fileList: true) ~> source1",
						"filterPogonStat select(mapColumn(",
						"          PRIMALAC_ROBE,",
						"          TIP_ISPORUKE,",
						"          DATUM = STVARNI_DATUM_ISPORUKE,",
						"          MATERIJAL,",
						"          KOLICINA,",
						"          SKLADISNA_LOKACIJA,",
						"          ODELJAK,",
						"          SIFRA_RAZLOGA_POVRATA,",
						"          OPIS_RAZLOGA_POVRATA",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRename",
						"sourceSAP filter(POGON=='MD10' && WBSTK == 'C') ~> filterPogonStat",
						"join1 split(TIP_ISPORUKE=='ZLX' || TIP_ISPORUKE =='ZLR',",
						"     disjoint: false) ~> split1@(Povrat, Komision)",
						"select4Col, sourceMat join(MATERIJAL == Sifra_materijala,",
						"     joinType:'inner',",
						"     broadcast: 'auto')~> joinMat",
						"filterRazlogPovrata select(mapColumn(",
						"          DATUM,",
						"          MATERIJAL,",
						"          KOLICINA,",
						"          ODELJAK,",
						"          SIFRA_RAZLOGA_POVRATA,",
						"          OPIS_RAZLOGA_POVRATA",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4Col",
						"joinMat derive(Kartona = round(KOLICINA /Broj_komada_u_kart, 0, 2),",
						"          Komada_ostalo = ( KOLICINA /Broj_komada_u_kart - round(KOLICINA /Broj_komada_u_kart, 0, 2) ) * Broj_komada_u_kart) ~> derivedKarton",
						"filterSkladKolic select(mapColumn(",
						"          PRIMALAC_ROBE,",
						"          DATUM,",
						"          ODELJAK,",
						"          KOLICINA",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3Col",
						"select3Col aggregate(groupBy(DATUM),",
						"     Stavka_na_komisionom_nalogu = count(KOLICINA),",
						"          Komisioni_nalog = countDistinct(PRIMALAC_ROBE)) ~> aggregateCount",
						"aggregateCount sort(asc(DATUM, true)) ~> sortDatum",
						"split1@Povrat filter(not (in(['P03', 'N03', 'N05', 'N05'], SIFRA_RAZLOGA_POVRATA))) ~> filterRazlogPovrata",
						"derivedKarton aggregate(groupBy(DATUM),",
						"     Povrat_robe_po_kartonu = sum(Kartona),",
						"          Stavka_na_komisionom_nalogu = sum(Komada_ostalo)) ~> aggregateSum",
						"aggregateSum sort(asc(DATUM, true)) ~> sortDat",
						"sortDatum derive(day_of_week = dayOfWeek(DATUM),",
						"          day_of_month = dayOfMonth(DATUM),",
						"          day_of_year = dayOfYear(DATUM),",
						"          week_of_year = weekOfYear(DATUM),",
						"          year = year(DATUM)) ~> derivedDate",
						"split1@Komision filter(not (in(['PRV1', 'PRV2', 'PRV3'], SKLADISNA_LOKACIJA)) && KOLICINA != 0) ~> filterSkladKolic",
						"selectRename, selectRenBrend join(selectRename@ODELJAK == selectRenBrend@Odeljak,",
						"     joinType:'inner',",
						"     broadcast: 'auto')~> join1",
						"sourceBrend select(mapColumn(",
						"          Odeljak,",
						"          Brend = Opis",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRenBrend",
						"derivedDate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['komisionAgg.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sinkKomis",
						"sortDat sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['povratAgg.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sinkPovrat"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_dl_sap_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_mat_xls')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_odeljak_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_processed_dmd_sink_csv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/df_marko_copy2')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_dl_sap_csv",
								"type": "DatasetReference"
							},
							"name": "sourceSAP"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_mat_xls",
								"type": "DatasetReference"
							},
							"name": "sourceMat"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_odeljak_csv",
								"type": "DatasetReference"
							},
							"name": "sourceBrend"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_dl_processed_dmd_sink_csv",
								"type": "DatasetReference"
							},
							"name": "sinkKomis"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_processed_dmd_sink_csv",
								"type": "DatasetReference"
							},
							"name": "sinkPovrat"
						},
						{
							"dataset": {
								"referenceName": "ds_dl_processed_dmd_sink_csv",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "selectRename"
						},
						{
							"name": "filterPogonStat"
						},
						{
							"name": "split1"
						},
						{
							"name": "joinMat"
						},
						{
							"name": "select4Col"
						},
						{
							"name": "derivedKarton"
						},
						{
							"name": "select3Col"
						},
						{
							"name": "aggregateCount"
						},
						{
							"name": "sortDatum"
						},
						{
							"name": "filterRazlogPovrata"
						},
						{
							"name": "aggregateSum"
						},
						{
							"name": "sortDat"
						},
						{
							"name": "derivedDate"
						},
						{
							"name": "filterSkladKolic"
						},
						{
							"name": "join1"
						},
						{
							"name": "selectRenBrend"
						}
					],
					"scriptLines": [
						"source(output(",
						"          DOKUMENT_ISPORUKE as integer,",
						"          STAVKA as integer,",
						"          OBLAST_PRODAJE as string,",
						"          WBSTK as string,",
						"          PRIMALAC_ROBE as long,",
						"          TIP_ISPORUKE as string,",
						"          TIP_PROD_DOK as string,",
						"          DATUM_ISPORUKE as date 'yyyyMMdd',",
						"          DOBAVLJAC as string,",
						"          PLANIRANI_DATUM_ISPORUKE as date 'yyyyMMdd',",
						"          STVARNI_DATUM_ISPORUKE as date 'yyyyMMdd',",
						"          MATERIJAL as integer,",
						"          KOLICINA as short,",
						"          SKLADISNA_LOKACIJA as string,",
						"          POGON as string,",
						"          ODELJAK as string,",
						"          SIFRA_RAZLOGA_POVRATA as string,",
						"          OPIS_RAZLOGA_POVRATA as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> sourceSAP",
						"source(output(",
						"          Sifra_materijala as integer,",
						"          Broj_komada_u_kart as short",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> sourceMat",
						"source(output(",
						"          Odeljak as string,",
						"          BRAND as short,",
						"          Opis as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> sourceBrend",
						"filterPogonStat select(mapColumn(",
						"          PRIMALAC_ROBE,",
						"          TIP_ISPORUKE,",
						"          DATUM = STVARNI_DATUM_ISPORUKE,",
						"          MATERIJAL,",
						"          KOLICINA,",
						"          SKLADISNA_LOKACIJA,",
						"          ODELJAK,",
						"          SIFRA_RAZLOGA_POVRATA,",
						"          OPIS_RAZLOGA_POVRATA",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRename",
						"sourceSAP filter(POGON=='MD10' && WBSTK == 'C'",
						"&& in(['10PZ', '40PZ', '90PZ','10CA', '10NI', 'PRM1', 'PRV1'], SKLADISNA_LOKACIJA)",
						"&& in(['ZLR', 'ZLX', 'LB', 'ZLA', 'ZLE', 'ZLO', 'ZLF', 'RL', 'Y73', 'YO3', 'YU3', 'YZO1', 'YZU1'], TIP_ISPORUKE)) ~> filterPogonStat",
						"join1 split(TIP_ISPORUKE=='ZLX' || TIP_ISPORUKE =='ZLR',",
						"     disjoint: false) ~> split1@(Povrat, Komision)",
						"select4Col, sourceMat join(MATERIJAL == Sifra_materijala,",
						"     joinType:'inner',",
						"     broadcast: 'auto')~> joinMat",
						"filterRazlogPovrata select(mapColumn(",
						"          DATUM,",
						"          MATERIJAL,",
						"          KOLICINA,",
						"          ODELJAK,",
						"          SIFRA_RAZLOGA_POVRATA,",
						"          OPIS_RAZLOGA_POVRATA",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4Col",
						"joinMat derive(Kartona = round(KOLICINA /Broj_komada_u_kart, 0, 2),",
						"          Komada_ostalo = ( KOLICINA /Broj_komada_u_kart - round(KOLICINA /Broj_komada_u_kart, 0, 2) ) * Broj_komada_u_kart) ~> derivedKarton",
						"filterSkladKolic select(mapColumn(",
						"          PRIMALAC_ROBE,",
						"          DATUM,",
						"          ODELJAK,",
						"          KOLICINA",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3Col",
						"select3Col aggregate(groupBy(DATUM),",
						"     Stavka_na_komisionom_nalogu = count(KOLICINA),",
						"          Komisioni_nalog = countDistinct(PRIMALAC_ROBE)) ~> aggregateCount",
						"aggregateCount sort(asc(DATUM, true)) ~> sortDatum",
						"split1@Povrat filter(not (in(['P03', 'N03', 'N05', 'N05'], SIFRA_RAZLOGA_POVRATA))) ~> filterRazlogPovrata",
						"derivedKarton aggregate(groupBy(DATUM),",
						"     Povrat_robe_po_kartonu = sum(Kartona),",
						"          Stavka_na_komisionom_nalogu = sum(Komada_ostalo)) ~> aggregateSum",
						"aggregateSum sort(asc(DATUM, true)) ~> sortDat",
						"sortDatum derive(day_of_week = dayOfWeek(DATUM),",
						"          day_of_month = dayOfMonth(DATUM),",
						"          day_of_year = dayOfYear(DATUM),",
						"          week_of_year = weekOfYear(DATUM),",
						"          year = year(DATUM)) ~> derivedDate",
						"split1@Komision filter(in(['10PZ', '40PZ', '90PZ'], SKLADISNA_LOKACIJA) ",
						"&& KOLICINA != 0 ",
						"&& in(['LB', 'ZLA', 'ZLE', 'ZLO', 'ZLF', 'RL', 'Y73', 'YO3', 'YU3', 'YZO1', 'YZU1'], TIP_ISPORUKE)) ~> filterSkladKolic",
						"selectRename, selectRenBrend join(selectRename@ODELJAK == selectRenBrend@Odeljak,",
						"     joinType:'left',",
						"     broadcast: 'auto')~> join1",
						"sourceBrend select(mapColumn(",
						"          Odeljak,",
						"          Brend = Opis",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRenBrend",
						"derivedDate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['komisionAgg.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sinkKomis",
						"sortDat sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['povratAgg.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sinkPovrat",
						"filterSkladKolic sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['test2preporc.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_dl_sap_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_mat_xls')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_odeljak_csv')]",
				"[concat(variables('workspaceId'), '/datasets/ds_dl_processed_dmd_sink_csv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/WorkspaceSystemIdentity')]",
			"type": "Microsoft.Synapse/workspaces/credentials",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "ManagedIdentity",
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL script DMD 2020')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'https://dlsynapsedts.dfs.core.windows.net/row/dmd/SAP/DMD_2020.csv',\n        FORMAT = 'CSV',\nâ¯â¯â¯â¯â¯â¯â¯â¯PARSER_VERSION = '2.0'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Notebook ML Model 2 bckp')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Archive"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "SparkSmall",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "62303929-b35f-4e38-8316-9e3d0d86d7d8"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/3d1a0d9a-7e0f-434a-bb08-b3b842299587/resourceGroups/Synapse_Analytics/providers/Microsoft.Synapse/workspaces/synapsedtsws/bigDataPools/SparkSmall",
						"name": "SparkSmall",
						"type": "Spark",
						"endpoint": "https://synapsedtsws.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/SparkSmall",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.1",
						"nodeCount": 10,
						"cores": 4,
						"memory": 28
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Import library"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\r\n",
							"import numpy as np\r\n",
							"\r\n",
							"from dateutil.parser import parse \r\n",
							"import matplotlib as mpl\r\n",
							"import matplotlib.pyplot as plt\r\n",
							"import matplotlib.pyplot as pyplot\r\n",
							"import seaborn as sns\r\n",
							"\r\n",
							"from datetime import datetime\r\n",
							"\r\n",
							"import warnings\r\n",
							"warnings.simplefilter(\"ignore\")\r\n",
							"\r\n",
							"from datetime import datetime\r\n",
							"import time\r\n",
							"import math\r\n",
							"\r\n",
							"from pandas.plotting import autocorrelation_plot\r\n",
							"\r\n",
							"# from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error, mean_absolute_percentage_error   # metrics\r\n",
							"from statsmodels.tsa.seasonal import seasonal_decompose\r\n",
							"from statsmodels.graphics.tsaplots import plot_pacf\r\n",
							"# from statsmodels.tsa.ar_model import AR\r\n",
							"# from statsmodels.tsa.arima_model import ARIMA\r\n",
							"from statsmodels.tsa.statespace.sarimax import SARIMAX\r\n",
							"from statsmodels.tsa.ar_model import AutoReg\r\n",
							"from statsmodels.tsa.arima.model import ARIMA\r\n",
							"# import pmdarima as pm\r\n",
							"\r\n",
							"\r\n",
							"plt.rcParams.update({'figure.figsize': (10, 7), 'figure.dpi': 120})\r\n",
							"print('jes importedddd je :D')"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Access Azure SQL database "
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"jdbcHostname = \"srv-db-sql-dmd.database.windows.net\"\r\n",
							"jdbcDatabase = \"db-sql-dmd\"\r\n",
							"jdbcPort = \"1433\"\r\n",
							"username = \"marko\"\r\n",
							"password = \"5Avramovic!\"\r\n",
							"jdbcUrl = \"jdbc:sqlserver://{0}:{1};database={2}\".format(jdbcHostname, jdbcPort, jdbcDatabase)\r\n",
							"connectionProperties = {\r\n",
							"    \"user\" : username,\r\n",
							"    \"password\" : password,\r\n",
							"    \"driver\" : \"com.microsoft.sqlserver.jdbc.SQLServerDriver\"\r\n",
							"}\r\n",
							"pushdown_query = \"(SELECT top(5) DATUM, STAVKE_NA_KOMIS_NALOGU FROM src.komisionOdeljAggFinal WHERE BREND = 'Ferrero') Ferrero\"\r\n",
							"df_ferrero = spark.read.jdbc(url=jdbcUrl, table=pushdown_query, properties=connectionProperties)\r\n",
							"display(df_ferrero)\r\n",
							"\r\n",
							""
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Access Data Lake Gen 2 using secret key - not working"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"microsoft": {
								"language": "python"
							}
						},
						"source": [
							"%%pyspark\r\n",
							"spark.conf.set(\"fs.azure.account.auth.type\", \"SAS\")\r\n",
							"spark.conf.set(\"fs.azure.sas.token.provider.type\", \"com.microsoft.azure.synapse.tokenlibrary.AkvBasedSASProvider\")\r\n",
							"spark.conf.set(\"spark.storage.synapse.akv\", \"https://dtsmlws9956541205.vault.azure.net/\")\r\n",
							"spark.conf.set(\"spark.storage.akv.secret\", \"jPsmUFd82epLoYrQVfsPilAsPmFd0y6EJ8TEzJzIDZIFU39eZqV2tfBR73ATfCeSaJp2DMJrYDuWEUwyojKKuw==\")\r\n",
							"\r\n",
							"df = spark.read.csv('abfss://row@dlsynapsedts.dfs.core.windows.net/dmd/SAP/DMD_2020.csv')\r\n",
							"# df = spark.read.csv('abfss://processed@dlsynapsedts.dfs.core.windows.net/dmd')\r\n",
							"\r\n",
							"\r\n",
							"display(df.limit(10))"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from notebookutils import mssparkutils\r\n",
							"# mssparkutils.credentials.help()\r\n",
							"accountKey = mssparkutils.credentials.getSecret('keywaultdts', 'secretdts')"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from notebookutils import mssparkutils  \r\n",
							"mssparkutils.fs.mount(\r\n",
							"    \"abfss://row@dlsynapsedts.dfs.core.windows.net\", #ADLS GEN 2 PATH\r\n",
							"    \"/test2\", #Mount Point Name\r\n",
							"    { \"accountKey\" : accountKey}\r\n",
							")"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Access Blob storage using AccountKey - pression issue"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from notebookutils import mssparkutils  \r\n",
							"mssparkutils.fs.mount(\r\n",
							"    \"abfss://row@dlsynapsedts.dfs.core.windows.net\", #ADLS GEN 2 PATH\r\n",
							"    \"/test\", #Mount Point Name\r\n",
							"    { \"accountKey\" : \"jPsmUFd82epLoYrQVfsPilAsPmFd0y6EJ8TEzJzIDZIFU39eZqV2tfBR73ATfCeSaJp2DMJrYDuWEUwyojKKuw==\"}\r\n",
							")\r\n",
							""
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"jobId = mssparkutils.env.getJobId()\r\n",
							"df = spark.read.load('synfs:/' + jobId + '/test/dmd/Odeljak/Odeljak_fix.csv', format = 'csv')\r\n",
							"display(df)"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Direct access from Data Lake Gen 2 - permision issue"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"microsoft": {
								"language": "python"
							},
							"collapsed": false
						},
						"source": [
							"%%pyspark\r\n",
							"df = spark.read.load('abfss://row@dlsynapsedts.dfs.core.windows.net/dmd/Odeljak/Odeljak_fix.csv', format='csv'\r\n",
							"## Ifâ¯headerâ¯existsâ¯uncommentâ¯lineâ¯below\r\n",
							", header=True\r\n",
							")\r\n",
							"display(df.limit(10))"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"df.write.mode('overwrite').option('header', 'true').csv('abfss://processed@dlsynapsedts.dfs.core.windows.net/dmd/')\r\n",
							""
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Output using Spark - Store output on Blob Storage - work"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Output using Spark\r\n",
							"folder_name = \"fererro\"\r\n",
							"(df\r\n",
							" .coalesce(1)\r\n",
							" .write\r\n",
							" .mode(\"overwrite\")\r\n",
							" .option(\"header\", \"true\")\r\n",
							" .format(\"com.databricks.spark.csv\")\r\n",
							" .save('abfss://processed@dlsynapsedts.dfs.core.windows.net/dmd/' + folder_name))"
						],
						"outputs": [],
						"execution_count": 20
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Library issue"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error       #, mean_absolute_percentage_error\r\n",
							""
						],
						"outputs": [],
						"execution_count": 46
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from sklearn.metrics import  mean_absolute_percentage_error\r\n",
							""
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import sklearn\r\n",
							"sklearn.show_versions()"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pip install -U scikit-learn\r\n",
							""
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Panda to spark function"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from pyspark.sql.types import *\r\n",
							"\r\n",
							"# Auxiliar functions\r\n",
							"def equivalent_type(f):\r\n",
							"    if f == 'datetime64[ns]': return TimestampType()\r\n",
							"    elif f == 'int64': return LongType()\r\n",
							"    elif f == 'int32': return IntegerType()\r\n",
							"    elif f == 'float64': return DoubleType()\r\n",
							"    elif f == 'float32': return FloatType()\r\n",
							"    else: return StringType()\r\n",
							"\r\n",
							"def define_structure(string, format_type):\r\n",
							"    try: typo = equivalent_type(format_type)\r\n",
							"    except: typo = StringType()\r\n",
							"    return StructField(string, typo)\r\n",
							"\r\n",
							"# Given pandas dataframe, it will return a spark's dataframe.\r\n",
							"def pandas_to_spark(pandas_df):\r\n",
							"    columns = list(pandas_df.columns)\r\n",
							"    types = list(pandas_df.dtypes)\r\n",
							"    struct_list = []\r\n",
							"    for column, typo in zip(columns, types): \r\n",
							"      struct_list.append(define_structure(column, typo))\r\n",
							"    p_schema = StructType(struct_list)\r\n",
							"    return sqlContext.createDataFrame(pandas_df, p_schema)"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"a = pandas_to_spark(prediction)\r\n",
							"display(a)"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Evaluating the models with data - create function"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def metric_table(test, predictions):\r\n",
							"    \r\n",
							"  mse = mean_squared_error(test, predictions)\r\n",
							"  model_r2, model_RMSE, model_MAE, model_MSE, model_MAPE, model_Adj_R2 = [], [], [], [], [], []\r\n",
							"\r\n",
							"\r\n",
							"  r2 = r2_score(test, predictions)\r\n",
							"  rmse = np.sqrt(mean_squared_error(test, predictions))\r\n",
							"  mae = mean_absolute_error(test, predictions)\r\n",
							"  mse = mean_squared_error(test, predictions)\r\n",
							"#   mape = mean_absolute_percentage_error(test, predictions)\r\n",
							"\r\n",
							"  # adj_r2 = 1-(1-r2)*(n-1)/(n-p-1)       # n - broj uzoraka, p - broj nezavis var\r\n",
							"  adj_r2 = 1-(1-r2)*(test.shape[0]-1)/(test.shape[0]-1-1)\r\n",
							"\r\n",
							"  model_r2.append(r2)\r\n",
							"  model_RMSE.append(rmse)\r\n",
							"  model_MAE.append(mae)\r\n",
							"  model_MSE.append(mse)\r\n",
							"#   model_MAPE.append(mape)\r\n",
							"  model_Adj_R2.append(adj_r2)\r\n",
							"\r\n",
							"\r\n",
							"  df_result = pd.DataFrame({\"R2\":model_r2, \"Adj_R2\": model_Adj_R2, \"RMSE\": model_RMSE, \"MAE\":model_MAE, \"MSE\": model_MSE})  #, \"MAPE\": model_MAPE})\r\n",
							"  df_result = round(df_result,3)\r\n",
							"  df_result = df_result.sort_values(\"R2\", ascending=False)\r\n",
							"  df_result\r\n",
							"  return df_result"
						],
						"outputs": [],
						"execution_count": 50
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Import dataset"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# set test set\r\n",
							"n = 15"
						],
						"outputs": [],
						"execution_count": 51
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"dataset = pd.read_csv('https://raw.githubusercontent.com/marko2212/test_data/main/DMD_dataset.csv', header=0, parse_dates=[0], dayfirst=True)\r\n",
							"df = dataset\r\n",
							"# df.index = df.iloc[:, 0]   \r\n",
							"df = df[df['DATUM'].dt.weekday != 6]         # removing sunday (6) from dummy df_date\r\n",
							"df = df.reset_index(drop=True)\r\n",
							"# df = features\r\n",
							"df"
						],
						"outputs": [],
						"execution_count": 52
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Test-Train Split"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"train, test = df.iloc[:-n, -1], df.iloc[-n:, -1]                                # values\r\n",
							"test_date = dataset.iloc[-n:, 0:1]\r\n",
							"train"
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"data = train\r\n",
							"predict =[]\r\n",
							"for t in test:\r\n",
							"    model = ARIMA(data, order=(5,1,1))\r\n",
							"    model_fit = model.fit()\r\n",
							"    y = model_fit.forecast()\r\n",
							"    print(y[0][0])\r\n",
							"    # print(y)                # for now model.ARIMA\r\n",
							"    predict.append(y[0][0])\r\n",
							"    # predict.append(y)         # for now model.ARIMA\r\n",
							"    data = np.append(data, t)\r\n",
							"    data = pd.Series(data)\r\n",
							"# predict"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\r\n",
							"import numpy as np\r\n",
							"import matplotlib.pyplot as plt\r\n",
							"\r\n",
							"# Load AutoReg class from statsmodels.tsa.ar_model module\r\n",
							"from statsmodels.tsa.ar_model import AutoReg\r\n",
							"# Load and plot the time-series data\r\n",
							"#\r\n",
							"url='https://raw.githubusercontent.com/jenfly/opsd/master/opsd_germany_daily.csv'\r\n",
							"df = pd.read_csv(url,sep=\",\")\r\n",
							"df['Consumption'].plot()"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#\r\n",
							"# Create training and test data\r\n",
							"#\r\n",
							"train_data = df['Consumption'][:len(df)-100]\r\n",
							"test_data = df['Consumption'][len(df)-100:]\r\n",
							"#\r\n",
							"# Instantiate and fit the AR model with training data\r\n",
							"#\r\n",
							"ar_model = AutoReg(train_data, lags=8).fit()\r\n",
							"#\r\n",
							"# Print Summary\r\n",
							"#\r\n",
							"print(ar_model.summary())"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"test_data\r\n",
							"test"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"model = ARIMA(train, order=(5,1,1))"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# from statsmodels.tsa.ar_model import AR       # deprecated\r\n",
							"from statsmodels.tsa.ar_model import AutoReg\r\n",
							"# statsmodels.tsa.AR has been deprecated in favor of statsmodels.tsa.AutoReg and\r\n",
							"# statsmodels.tsa.SARIMAX.\r\n",
							"# model = AR(train)                           # deprecated\r\n",
							"model = AutoReg(train, lags=21)\r\n",
							"model_fit = model.fit()\r\n",
							"model_fit\r\n",
							"# model_fit.summary()"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"model_fit.forecast().values[0]"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"data = train\r\n",
							"predict =[]\r\n",
							"for t in test:\r\n",
							"    model = ARIMA(data, order=(5,1,1))\r\n",
							"    model_fit = model.fit()\r\n",
							"    y = model_fit.forecast()\r\n",
							"    # print(y[0][0])\r\n",
							"    print(y.values[0])\r\n",
							"    # print(y)                # for now model.ARIMA\r\n",
							"    # predict.append(y[0][0])\r\n",
							"    predict.append(y.values[0])\r\n",
							"    # predict.append(y)         # for now model.ARIMA\r\n",
							"    data = np.append(data, t)\r\n",
							"    data = pd.Series(data)\r\n",
							"# predict"
						],
						"outputs": [],
						"execution_count": 13
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pyplot.figure(figsize=(8, 5), dpi=80)\r\n",
							"\r\n",
							"pyplot.plot(test.values)\r\n",
							"pyplot.plot(predict, color='red')\r\n",
							"pyplot.show()\r\n",
							"metric_table(test, predict)             # metric table"
						],
						"outputs": [],
						"execution_count": 32
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Regression"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"\r\n",
							"y = dataset.iloc[:, -1].values\r\n",
							"\r\n",
							"# Select all types of numerical data\r\n",
							"numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64'] \r\n",
							"numerical_df = dataset.select_dtypes(include=numerics)\r\n",
							"X = numerical_df.iloc[:, :-1]\r\n",
							"d = dataset\r\n",
							"d['day']             = d['DATUM'].dt.day\r\n",
							"d[['day']]\r\n",
							"X = d[['day']]\r\n",
							"y"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from sklearn.model_selection import train_test_split\r\n",
							"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 0)\r\n",
							"X_train"
						],
						"outputs": [],
						"execution_count": 68
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from sklearn.preprocessing import StandardScaler\r\n",
							"sc = StandardScaler()\r\n",
							"X_train = sc.fit_transform(X_train)\r\n",
							"X_test = sc.transform(X_test)"
						],
						"outputs": [],
						"execution_count": 69
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Evaluating the models with data using this function\r\n",
							"\r\n",
							"model_r2, model_RMSE, model_MAE, model_MSE = [], [], [], []\r\n",
							"\r\n",
							"def evaluate(model):\r\n",
							"    model.fit(X_train,y_train)\r\n",
							"    y_pred=model.predict(X_test) \r\n",
							"    \r\n",
							"    # printing the model name and scores\r\n",
							"    r2 = r2_score(y_test, y_pred)\r\n",
							"    rmse = np.sqrt(mean_squared_error(y_test, y_pred))\r\n",
							"    mae = mean_absolute_error(y_test, y_pred)\r\n",
							"    mse = mean_squared_error(y_test, y_pred)\r\n",
							"    print(\"Model name:------->    \",model)\r\n",
							"    print(\"R2   score:------->\",round(r2,2))\r\n",
							"    print('RMSE score:------->',round(rmse,2))\r\n",
							"    print('MAE  score:------->',round(mae,2))\r\n",
							"    print('MSE  score:------->',round(mse,2))\r\n",
							"    print(\"<<<<-------------------------------------------------------------------->>>>\")\r\n",
							"    model_r2.append(r2)\r\n",
							"    model_RMSE.append(rmse)\r\n",
							"    model_MAE.append(mae)\r\n",
							"    model_MSE.append(mse)"
						],
						"outputs": [],
						"execution_count": 70
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Initialize the models\r\n",
							"lir = LinearRegression()                                                                      # linear regression\r\n",
							"pr = LinearRegression()                                                                       # polynomial regression\r\n",
							"logr = LogisticRegression()\r\n",
							"dtr = DecisionTreeRegressor(random_state = 0)                                                 # decision tree regression\r\n",
							"rfr = RandomForestRegressor(n_estimators = 100, random_state = 0)                             # random forest regression\r\n",
							"svr = SVR(kernel = 'rbf')                                                                     # support vector regression\r\n",
							"rr = Ridge(alpha=1.0)                                                                         # ridge regression\r\n",
							"lsr = Lasso(alpha=2.0, max_iter = 10000)                                                      # lasso regression\r\n",
							"knn = neighbors.KNeighborsRegressor()                                                         # KNeighbors regression\r\n",
							"xgb = XGBRegressor()                                                                          # XGBRegressor\r\n",
							"# xgb = XGBRegressor(n_estimators=1000, max_depth=7, eta=0.1, subsample=0.7, colsample_bytree=0.8)\r\n",
							"# xgb = XGBClassifier(learning_rate=0.1,n_estimators=500,random_state=42)\r\n",
							"\r\n",
							"poly_reg = PolynomialFeatures(degree = 4)\r\n",
							"X_poly = poly_reg.fit_transform(X_train)\r\n",
							"\r\n",
							"models=[lir, pr,logr,  dtr, rfr, svr, rr, lsr, knn, xgb] #create a list of models\r\n",
							"model_names = ['Linear Regression', 'Polynomial Regression','Logistic Regression', 'Decision Tree Regressoion', 'Random Forest Regression',\r\n",
							"               'Support Vector Regression', 'Ridge regression', 'Lasso regression', 'KNeighbors regression', 'XGB Regression']\r\n",
							"\r\n",
							"\r\n",
							"for model in models:\r\n",
							"    evaluate(model)"
						],
						"outputs": [],
						"execution_count": 71
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# sort models by r2\r\n",
							"df_result = pd.DataFrame({\"R2\":model_r2, \"RMSE\": model_RMSE, \"MAE\":model_MAE, \"MSE\": model_MSE, \"ML Models\": model_names})\r\n",
							"df_result = round(df_result,3)\r\n",
							"df_result = df_result.sort_values(\"R2\", ascending=False)\r\n",
							"df_result.style\\\r\n",
							"    .background_gradient(\"Blues\",  subset=['R2'])\\\r\n",
							"    .background_gradient(\"Blues_r\",  subset=['RMSE', 'MAE', 'MSE'])"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from sklearn.ensemble import RandomForestRegressor\r\n",
							"regressor = RandomForestRegressor(n_estimators = 100, random_state = 0)\r\n",
							"regressor.fit(X_train, y_train)"
						],
						"outputs": [],
						"execution_count": 72
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"y_pred = rfr.predict(X_test)\r\n",
							"np.set_printoptions(precision=2)\r\n",
							"\r\n",
							"df_result = pd.DataFrame({\"predicted\":np.round(y_pred), \"real\": y_test, \"diff\": abs(np.round(y_pred) - y_test)})\r\n",
							"df_result['diff%'] = df_result['diff'] / df_result['real']*100 \r\n",
							"# df_result = df_result.astype(int)\r\n",
							"# df_result\r\n",
							"# df_result[\"diff%\"].mean()\r\n",
							"# df_result[\"real\"].mean()\r\n",
							"# df_result\r\n",
							"# df_result['diff_2'] = df_result['diff'] *df_result['diff']\r\n",
							"# df_result['diff_2'].sum()/25\r\n",
							"# df_result[['diff']].sum()/25\r\n",
							"# df_result['diff'].total()\r\n",
							"df_result"
						],
						"outputs": [],
						"execution_count": 73
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"plt.figure(figsize=(8,5))\r\n",
							"# plt.figure(figsize=(20,7))\r\n",
							"plt.plot(y_pred, linestyle='-', marker='o', label='predicted')\r\n",
							"plt.plot(y_test,  label='real')\r\n",
							"plt.title('Real vs Predicted')\r\n",
							"# plt.grid(axis='y')\r\n",
							"plt.legend()\r\n",
							"plt.show()"
						],
						"outputs": [],
						"execution_count": 76
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pip install -U scikit-learn\r\n",
							""
						],
						"outputs": [],
						"execution_count": 77
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"Connect to database - take brend"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# bckp \r\n",
							"\r\n",
							"# connect to database with credentials, execut SQL \r\n",
							"item = 'STAVKE_NA_KOMIS_NALOGU'\r\n",
							"brend = 'Grupno'\r\n",
							"pushdown_query = \"(SELECT DATUM, {0} FROM src.komisionAggFinal ) {1}\".format(item,brend) \r\n",
							"# pushdown_query = \"(SELECT DATUM, STAVKE_NA_KOMIS_NALOGU FROM src.komisionAggFinal ) Grupno\"\r\n",
							"df_spark = spark.read.jdbc(url=jdbcUrl, table=pushdown_query, properties=connectionProperties)\r\n",
							"# display(df_spark)\r\n",
							"df = df_spark.toPandas()                      # Spark df to Pandas df\r\n",
							"\r\n",
							"df.set_index('DATUM', inplace=True)           # convert DATUM column to index\r\n",
							"df.index = pd.to_datetime(df.index)           # convert index to datetime\r\n",
							"df = add_all_date(df, )                       # add all missing date with (df, 0) or without (df, 1) sunday\r\n",
							"df\r\n",
							"\r\n",
							""
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# bckp\r\n",
							"\r\n",
							"# prediction_contaier = None\r\n",
							"\r\n",
							"if 'prediction_contaier' not in locals():               # ako prediction_contaier ne postoji kreiraj ga od prve predikcije\r\n",
							"    prediction_contaier = prediction\r\n",
							"\r\n",
							"if prediction_contaier is None:\r\n",
							"    prediction_contaier = prediction\r\n",
							"else:\r\n",
							"  print(\"a and b are equal\")\r\n",
							"#   pd.merge(prediction_contaier, prediction, left_index=True, right_index=True)\r\n",
							"prediction_contaier = prediction_contaier.join(prediction, how='left', lsuffix='_left', rsuffix='_right')\r\n",
							"\r\n",
							"prediction_contaier"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# prediction.reset_index(drop=False,inplace=True).set_index('DATUM')            # covert index to column\r\n",
							"# prediction = prediction.reset_index().set_index('DATUM', drop=False)          # covert index to column but keep index\r\n",
							"\r\n",
							"prediction_contaier['DATUM'] = prediction_contaier.index                      # covert index to column - other way\r\n",
							"# sat DATUM column to be first\r\n",
							"column_name = list(prediction_contaier.columns.values)\r\n",
							"column_name_wo_datum = column_name\r\n",
							"column_name_wo_datum.remove('DATUM')\r\n",
							"prediction_contaier = prediction_contaier[['DATUM'] + column_name_wo_datum]\r\n",
							"\r\n",
							"\r\n",
							"\r\n",
							"# prediction_contaier = prediction_contaier[[column_name[-1]] + column_name[:-1]]\r\n",
							"\r\n",
							"prediction_contaier.head()\r\n",
							""
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# # Output using Spark\r\n",
							"# folder_name = \"Fererro\"\r\n",
							"# (pandas_to_spark(prediction2)\r\n",
							"#  .coalesce(1)\r\n",
							"#  .write\r\n",
							"#  .mode(\"overwrite\")\r\n",
							"#  .option(\"header\", \"true\")\r\n",
							"#  .format(\"com.databricks.spark.csv\")\r\n",
							"#  .save('abfss://processed@dlsynapsedts.dfs.core.windows.net/dmd/Komision_stavke/' + folder_name))"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# covert pandadf to spark df\r\n",
							"prediction_spark = sqlContext.createDataFrame(prediction_contaier)            # convert pandadf to spark df\r\n",
							"display(prediction_spark)"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Train ARIMA model and prediction"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"n = 19\r\n",
							"order = [28,0,0]\r\n",
							"order = [3,0,0]\r\n",
							"model = ARIMA(df, order=(order))\r\n",
							"model_fit = model.fit()\r\n",
							"prediction = model_fit.forecast(n)\r\n",
							"\r\n",
							"# korekcije\r\n",
							"prediction = prediction.clip(lower=0)                           # sve negativne vrednosti svedi na 0\r\n",
							"prediction = add_all_date(prediction)                           # set sundey to 0\r\n",
							"prediction = prediction.rename(columns={'predicted_mean': item})        # set the name of column as item\r\n",
							"prediction.head()\r\n",
							"\r\n",
							"# ako prediction_contaier ne postoji kreiraj ga od prve predikcije, u suprotnom dodaj novu predikciju na prediction_contaier\r\n",
							"if 'prediction_contaier' not in locals():               \r\n",
							"    prediction_contaier = prediction\r\n",
							"else:\r\n",
							"    prediction_contaier = prediction_contaier.join(prediction, how='left', lsuffix='_left', rsuffix='_right')\r\n",
							"prediction_contaier.head()"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Import dataset"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# connect to database with credentials, execut SQL \r\n",
							"# STAVKE_NA_KOMIS_NALOGU, KOMIS_NALOG, POVRAT_KARTON, POVRAT_KOMAD,  komisionAggFinal,  povratAggFinal\r\n",
							"item = 'STAVKE_NA_KOMIS_NALOGU'\r\n",
							"brend = 'Grupno'\r\n",
							"table = 'src.komisionAggFinal'\r\n",
							"\r\n",
							"pushdown_query = \"(SELECT DATUM, {0} FROM {2} ) {1}\".format(item,brend,table) \r\n",
							"df_spark = spark.read.jdbc(url=jdbcUrl, table=pushdown_query, properties=connectionProperties)\r\n",
							"df = df_spark.toPandas()                      # Spark df to Pandas df\r\n",
							"\r\n",
							"df.set_index('DATUM', inplace=True)           # convert DATUM column to index\r\n",
							"df.index = pd.to_datetime(df.index)           # convert index to datetime\r\n",
							"df = add_all_date(df, )                       # add all missing date with (df, 0) or without (df, 1) sunday\r\n",
							"df.head(2)\r\n",
							""
						],
						"outputs": [],
						"execution_count": null
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Notebook ML Model 2 train')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "SparkSmall",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "50308cf2-43a5-42d2-9233-cae21ffc74d2"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/3d1a0d9a-7e0f-434a-bb08-b3b842299587/resourceGroups/Synapse_Analytics/providers/Microsoft.Synapse/workspaces/synapsedtsws/bigDataPools/SparkSmall",
						"name": "SparkSmall",
						"type": "Spark",
						"endpoint": "https://synapsedtsws.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/SparkSmall",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.1",
						"nodeCount": 10,
						"cores": 4,
						"memory": 28
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Import library"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import numpy as np\r\n",
							"import pandas as pd\r\n",
							"from pandas.plotting import autocorrelation_plot\r\n",
							"import matplotlib as mpl\r\n",
							"import matplotlib.pyplot as pyplot\r\n",
							"import matplotlib.pyplot as plt\r\n",
							"import seaborn as sns\r\n",
							"\r\n",
							"from datetime import datetime, timedelta\r\n",
							"import time\r\n",
							"from dateutil.parser import parse \r\n",
							"import math\r\n",
							"\r\n",
							"import warnings\r\n",
							"warnings.simplefilter(\"ignore\")\r\n",
							"\r\n",
							"from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error   # metrics\r\n",
							"from statsmodels.tsa.seasonal import seasonal_decompose\r\n",
							"from statsmodels.graphics.tsaplots import plot_pacf\r\n",
							"from statsmodels.tsa.statespace.sarimax import SARIMAX\r\n",
							"from statsmodels.tsa.ar_model import AutoReg\r\n",
							"from statsmodels.tsa.arima.model import ARIMA\r\n",
							"import pmdarima as pm\r\n",
							"\r\n",
							"from sklearn.ensemble import RandomForestRegressor\r\n",
							"from sklearn.linear_model import LinearRegression\r\n",
							"from sklearn.preprocessing import PolynomialFeatures\r\n",
							"from sklearn.tree import DecisionTreeRegressor\r\n",
							"from sklearn.model_selection import cross_val_score\r\n",
							"from sklearn.svm import SVR\r\n",
							"from sklearn.linear_model import LogisticRegression\r\n",
							"from sklearn.linear_model import Ridge\r\n",
							"from sklearn.linear_model import Lasso\r\n",
							"from sklearn import neighbors\r\n",
							"from xgboost import XGBRegressor \r\n",
							"\r\n",
							"pyplot.rcParams.update({'figure.figsize': (10, 7), 'figure.dpi': 120})\r\n",
							"print('lib are imported')"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Evaluating the models with data - create function"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def metric_table(test, predictions):\r\n",
							"    \r\n",
							"  mse = mean_squared_error(test, predictions)\r\n",
							"  model_r2, model_RMSE, model_MAE, model_MSE, model_Adj_R2 = [], [], [], [], []\r\n",
							"\r\n",
							"\r\n",
							"  r2 = r2_score(test, predictions)\r\n",
							"  rmse = np.sqrt(mean_squared_error(test, predictions))\r\n",
							"  mae = mean_absolute_error(test, predictions)\r\n",
							"  mse = mean_squared_error(test, predictions)\r\n",
							"  # mape = mean_absolute_percentage_error(test, predictions)\r\n",
							"\r\n",
							"  # adj_r2 = 1-(1-r2)*(n-1)/(n-p-1)       # n - broj uzoraka, p - broj nezavis var\r\n",
							"  adj_r2 = 1-(1-r2)*(test.shape[0]-1)/(test.shape[0]-1-1)\r\n",
							"\r\n",
							"  model_r2.append(r2)\r\n",
							"  model_RMSE.append(rmse)\r\n",
							"  model_MAE.append(mae)\r\n",
							"  model_MSE.append(mse)\r\n",
							"  # model_MAPE.append(mape)\r\n",
							"  model_Adj_R2.append(adj_r2)\r\n",
							"\r\n",
							"\r\n",
							"  df_result = pd.DataFrame({\"R2\":model_r2, \"Adj_R2\": model_Adj_R2, \"RMSE\": model_RMSE, \"MAE\":model_MAE, \"MSE\": model_MSE})\r\n",
							"  df_result = round(df_result,3)\r\n",
							"  df_result = df_result.sort_values(\"R2\", ascending=False)\r\n",
							"  df_result\r\n",
							"  return df_result"
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Create function that add all missing date"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def add_all_date(df, whitout_sun=0):\r\n",
							"  rng = pd.date_range(start = df.index[0], end =df.index[-1],  freq='D')        # pocetni datum je prvi index (datum), rajnji datum je poslednji red indexa\r\n",
							"  df_date_temp = pd.DataFrame({ 'DATUM': rng}) \r\n",
							"  if whitout_sun == 1:\r\n",
							"    df_date_temp = df_date_temp[df_date_temp['DATUM'].dt.weekday != 6]          # removing sunday (6) from dummy df_date_temp\r\n",
							"  df_date_temp.set_index('DATUM', inplace=True)                                 # set column date as index\r\n",
							"  df = df[df.index.weekday != 6]                                                # removing sunday (6) from df\r\n",
							"  df = df_date_temp.join(df)                                                    # left join dataset on dummy date\r\n",
							"  df = df.fillna(0)                                                             # fill NaN values with 0\r\n",
							"  df = df.iloc[:,-1:].astype(int)                                               # convert string to int\r\n",
							"  return df\r\n",
							""
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Create function that group date by week"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def group_by_week(df):\r\n",
							"  df['year_month_week'] = df.index.strftime('%Y_%m') + '_' + df.index.week.astype(str)      # create year_month_week from index\r\n",
							"  df_week = df.groupby('year_month_week').sum()         # group df by week\r\n",
							"  return df_week"
						],
						"outputs": [],
						"execution_count": 17
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Import dataset"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": true,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# credentials\r\n",
							"jdbcHostname = \"srv-db-sql-dmd.database.windows.net\"\r\n",
							"jdbcDatabase = \"db-sql-dmd\"\r\n",
							"jdbcPort = \"1433\"\r\n",
							"username = \"marko\"\r\n",
							"password = \"5Avramovic!\"\r\n",
							"jdbcUrl = \"jdbc:sqlserver://{0}:{1};database={2}\".format(jdbcHostname, jdbcPort, jdbcDatabase)\r\n",
							"connectionProperties = {\r\n",
							"    \"user\" : username,\r\n",
							"    \"password\" : password,\r\n",
							"    \"driver\" : \"com.microsoft.sqlserver.jdbc.SQLServerDriver\"\r\n",
							"}"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# connect to database with credentials, execut SQL \r\n",
							"pushdown_query = \"(SELECT DATUM, STAVKE_NA_KOMIS_NALOGU FROM src.komisionAggFinal ) Grupno\"\r\n",
							"df_spark = spark.read.jdbc(url=jdbcUrl, table=pushdown_query, properties=connectionProperties)\r\n",
							"# display(df_spark)\r\n",
							"df = df_spark.toPandas()                      # Spark df to Pandas df\r\n",
							"\r\n",
							"df.set_index('DATUM', inplace=True)\r\n",
							"df.index = pd.to_datetime(df.index)           # convert index to datetime\r\n",
							"df"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Test-Train Split"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"n = 19\r\n",
							"\r\n",
							"df = add_all_date(df, )      # add all missing date with (df, 0) or without (df, 1) sunday\r\n",
							"train = df.iloc[:-n]\r\n",
							"test = df.iloc[-n:]\r\n",
							"\r\n",
							"test.head()"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Train ARIMA model and prediction"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# model = ARIMA(train, order=(p,d,q))\r\n",
							"order = [28,1,1]\r\n",
							"model = ARIMA(train, order=(order))\r\n",
							"model_fit = model.fit()\r\n",
							"prediction = model_fit.forecast(n)\r\n",
							"\r\n",
							"if not isinstance(prediction.index[0], datetime):               # ako index nije datum pretvori ga u datum\r\n",
							"  prediction = prediction.to_frame().set_index(test.index)      # move series to dataframe and set index as test datum\r\n",
							"\r\n",
							"# korekcije\r\n",
							"prediction = prediction.clip(lower=0)                           # sve negativne vrednosti svedi na 0\r\n",
							"prediction = add_all_date(prediction)                           # set sundey to 0\r\n",
							"prediction"
						],
						"outputs": [],
						"execution_count": 14
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Graph"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# pyplot.figure(figsize=(8, 5), dpi=80)       # adjust graph size\r\n",
							"pyplot.figure(figsize=(20, 7), dpi=80)       # adjust graph size\r\n",
							"pyplot.plot(prediction, color='red', label='prediction')\r\n",
							"pyplot.plot(test, label='real')\r\n",
							"pyplot.legend(loc=\"upper left\")\r\n",
							"pyplot.show()\r\n",
							"# print(order)\r\n",
							"metric_table(test, prediction)             # metric table\r\n",
							""
						],
						"outputs": [],
						"execution_count": 15
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Group by week after day prediction and plot"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"prediction_week = group_by_week(prediction)\r\n",
							"test_week = group_by_week(test)\r\n",
							"pyplot.figure(figsize=(20, 7), dpi=80)       # adjust graph size\r\n",
							"pyplot.plot(prediction_week, color='red', label='prediction')\r\n",
							"pyplot.plot(test_week, label='real')\r\n",
							"pyplot.legend(loc=\"upper left\")\r\n",
							"\r\n",
							"round(prediction_week).to_csv('prediction_week.csv', sep=',', encoding='utf-8')        # download prediction_week\r\n",
							"round(test_week).to_csv('test_week.csv', sep=',', encoding='utf-8')                    # download prediction_week\r\n",
							"print(order)\r\n",
							"metric_table(test_week, prediction_week)             # metric table"
						],
						"outputs": [],
						"execution_count": 18
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# %%pyspark\r\n",
							"# df = spark.read.load('abfss://row@dlsynapsedts.dfs.core.windows.net/dmd/SAP/DMD_2020.csv', format='csv'\r\n",
							"# ## Ifâ¯headerâ¯existsâ¯uncommentâ¯lineâ¯below\r\n",
							"# ##, header=True\r\n",
							"# )\r\n",
							"# display(df.limit(10))"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							""
						]
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Grid search ARIMA"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# grid search ARIMA parameters for time series\r\n",
							"import warnings\r\n",
							"from math import sqrt\r\n",
							"from pandas import read_csv\r\n",
							"from statsmodels.tsa.arima.model import ARIMA\r\n",
							"from sklearn.metrics import mean_squared_error\r\n",
							"\r\n",
							"# create empty metric_grid\r\n",
							"metric_grid = pd.DataFrame(columns=['0,0'])\r\n",
							"metric_grid_average = pd.DataFrame(columns=['order'])\r\n",
							"\r\n",
							"# evaluate an ARIMA model for a given order (p,d,q)\r\n",
							"def evaluate_arima_model(X, arima_order):\r\n",
							"\t# empty metric_grid\r\n",
							"\tmetric_grid = pd.DataFrame(columns=['0,0'])\r\n",
							"\t# prepare training dataset\r\n",
							"\t# train_size = int(len(X) * 0.97)\r\n",
							"\ttrain_size = len(X)-n\r\n",
							"\ttrain, test = X[0:train_size], X[train_size:]\r\n",
							"\thistory = [x for x in train]\r\n",
							"\t# make predictions\r\n",
							"\tpredictions = list()\r\n",
							"\tfor t in range(len(test)):\r\n",
							"\t\tmodel = ARIMA(history, order=arima_order)\r\n",
							"\t\tmodel_fit = model.fit()\r\n",
							"\t\tyhat = model_fit.forecast()[0]\r\n",
							"\t\tpredictions.append(yhat)\r\n",
							"\t\thistory.append(test[t])\r\n",
							"\t# calculate out of sample error\r\n",
							"\t# rmse = sqrt(mean_squared_error(test, predictions))\r\n",
							"\tmape = mean_squared_error(test, predictions)\r\n",
							"\treturn mape\r\n",
							" \r\n",
							"# evaluate combinations of p, d and q values for an ARIMA model\r\n",
							"def evaluate_models(dataset, p_values, d_values, q_values):\r\n",
							"\tdataset = dataset.astype('float32')\r\n",
							"\tbest_score, best_cfg = float(\"inf\"), None\r\n",
							"\tfor p in p_values:\r\n",
							"\t\tfor d in d_values:\r\n",
							"\t\t\tfor q in q_values:\r\n",
							"\t\t\t\torder = (p,d,q)\r\n",
							"\t\t\t\ttry:\r\n",
							"\t\t\t\t\tmape = evaluate_arima_model(dataset, order)\r\n",
							"\t\t\t\t\tif mape < best_score:\r\n",
							"\t\t\t\t\t\tbest_score, best_cfg = mape, order\r\n",
							"\t\t\t\t\tprint('ARIMA%s MSE=%.3f' % (order,mape))\r\n",
							"          # fill metric_grid with mape result\r\n",
							"\t\t\t\t\td_q = str(d) + ',' + str(q)\r\n",
							"\t\t\t\t\tmetric_grid.loc[p, d_q] = round(mape,3)\r\n",
							"\t\t\t\texcept:\r\n",
							"\t\t\t\t\tcontinue\r\n",
							"\tprint('Best ARIMA%s MSE=%.3f' % (best_cfg, best_score))\r\n",
							" "
						],
						"outputs": [],
						"execution_count": 19
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# load dataset\r\n",
							"n = 30\r\n",
							"t_now = datetime.now()\r\n",
							"series = pd.read_csv('https://raw.githubusercontent.com/marko2212/test_data/main/DMD_stavke_komis_dataset.csv',index_col='DATUM', header=0, parse_dates=[0], dayfirst=True)\r\n",
							"# evaluate parameters\r\n",
							"# p_values = [0, 1, 2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28, 29, 30]\r\n",
							"p_values = [0,1, 2]\r\n",
							"d_values = range(0, 2)\r\n",
							"q_values = range(0, 2)\r\n",
							"warnings.filterwarnings(\"ignore\")\r\n",
							"evaluate_models(series.values, p_values, d_values, q_values)\r\n",
							"\r\n",
							"print(datetime.now() - t_now)"
						],
						"outputs": [],
						"execution_count": 21
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Regression"
						]
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Features engineering"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# creating new features year, month, day\r\n",
							"df['DATUM'] = df.index\r\n",
							"features = df\r\n",
							"features['year']            = features['DATUM'].dt.year\r\n",
							"features['month']           = features['DATUM'].dt.month\r\n",
							"features['week']            = features['DATUM'].dt.week\r\n",
							"features['day']             = features['DATUM'].dt.day\r\n",
							"features['quarter']         = features['DATUM'].dt.quarter\r\n",
							"features['weekofyear']      = features['DATUM'].dt.weekofyear\r\n",
							"features['year_month']      = features['DATUM'].dt.strftime('%Y-%m')\r\n",
							"# features['YEAR_WEEK']           = features.index.strftime('%Y-w%U')         # Year week 2019-w21\r\n",
							"\r\n",
							"features['weekday']         = features['DATUM'].dt.weekday              # day in week\r\n",
							"features['days_in_month']   = features['DATUM'].dt.days_in_month        # number of day in month\r\n",
							"features['flag_is_weekend'] = np.where(features['weekday'] > 4, 1, 0)   # since none order is created on weekend this feature is usfficient\r\n",
							"features['week_start']      = features['DATUM'].dt.to_period('W').apply(lambda r: r.start_time)   # week start date\r\n",
							"\r\n",
							"features"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							""
						]
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Notebook ML Model')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "SparkSmall",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "bd98ab69-4b8c-4950-a37a-3fb5a41e38b2"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/3d1a0d9a-7e0f-434a-bb08-b3b842299587/resourceGroups/Synapse_Analytics/providers/Microsoft.Synapse/workspaces/synapsedtsws/bigDataPools/SparkSmall",
						"name": "SparkSmall",
						"type": "Spark",
						"endpoint": "https://synapsedtsws.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/SparkSmall",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.1",
						"nodeCount": 10,
						"cores": 4,
						"memory": 28,
						"automaticScaleJobs": false
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Import library"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import numpy as np\r\n",
							"import pandas as pd\r\n",
							"from pandas.plotting import autocorrelation_plot\r\n",
							"import matplotlib as mpl\r\n",
							"import matplotlib.pyplot as pyplot\r\n",
							"import matplotlib.pyplot as plt\r\n",
							"import seaborn as sns\r\n",
							"\r\n",
							"from datetime import datetime, timedelta\r\n",
							"import time\r\n",
							"from dateutil.parser import parse \r\n",
							"import math\r\n",
							"\r\n",
							"import warnings\r\n",
							"warnings.simplefilter(\"ignore\")\r\n",
							"\r\n",
							"from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error   # metrics\r\n",
							"from statsmodels.tsa.seasonal import seasonal_decompose\r\n",
							"from statsmodels.graphics.tsaplots import plot_pacf\r\n",
							"from statsmodels.tsa.statespace.sarimax import SARIMAX\r\n",
							"from statsmodels.tsa.ar_model import AutoReg\r\n",
							"from statsmodels.tsa.arima.model import ARIMA\r\n",
							"import pmdarima as pm\r\n",
							"\r\n",
							"pyplot.rcParams.update({'figure.figsize': (10, 7), 'figure.dpi': 120})\r\n",
							"print('lib are imported')"
						],
						"outputs": [],
						"execution_count": 591
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Evaluating the models with data - create function"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def metric_table(test, predictions):\r\n",
							"    \r\n",
							"  mse = mean_squared_error(test, predictions)\r\n",
							"  model_r2, model_RMSE, model_MAE, model_MSE, model_Adj_R2 = [], [], [], [], []\r\n",
							"\r\n",
							"\r\n",
							"  r2 = r2_score(test, predictions)\r\n",
							"  rmse = np.sqrt(mean_squared_error(test, predictions))\r\n",
							"  mae = mean_absolute_error(test, predictions)\r\n",
							"  mse = mean_squared_error(test, predictions)\r\n",
							"  # mape = mean_absolute_percentage_error(test, predictions)\r\n",
							"\r\n",
							"  # adj_r2 = 1-(1-r2)*(n-1)/(n-p-1)       # n - broj uzoraka, p - broj nezavis var\r\n",
							"  adj_r2 = 1-(1-r2)*(test.shape[0]-1)/(test.shape[0]-1-1)\r\n",
							"\r\n",
							"  model_r2.append(r2)\r\n",
							"  model_RMSE.append(rmse)\r\n",
							"  model_MAE.append(mae)\r\n",
							"  model_MSE.append(mse)\r\n",
							"  # model_MAPE.append(mape)\r\n",
							"  model_Adj_R2.append(adj_r2)\r\n",
							"\r\n",
							"\r\n",
							"  df_result = pd.DataFrame({\"R2\":model_r2, \"Adj_R2\": model_Adj_R2, \"RMSE\": model_RMSE, \"MAE\":model_MAE, \"MSE\": model_MSE})\r\n",
							"  df_result = round(df_result,3)\r\n",
							"  df_result = df_result.sort_values(\"R2\", ascending=False)\r\n",
							"  df_result\r\n",
							"  return df_result"
						],
						"outputs": [],
						"execution_count": 592
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Create function that add all missing date"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def add_all_date(df, whitout_sun=0):\r\n",
							"  rng = pd.date_range(start = df.index[0], end =df.index[-1],  freq='D')        # pocetni datum je prvi index (datum), rajnji datum je poslednji red indexa\r\n",
							"  df_date_temp = pd.DataFrame({ 'DATUM': rng}) \r\n",
							"  if whitout_sun == 1:\r\n",
							"    df_date_temp = df_date_temp[df_date_temp['DATUM'].dt.weekday != 6]          # removing sunday (6) from dummy df_date_temp\r\n",
							"  df_date_temp.set_index('DATUM', inplace=True)                                 # set column date as index\r\n",
							"  df = df[df.index.weekday != 6]                                                # removing sunday (6) from df\r\n",
							"  df = df_date_temp.join(df)                                                    # left join dataset on dummy date\r\n",
							"  df = df.fillna(0)                                                             # fill NaN values with 0\r\n",
							"  df = df.iloc[:,-1:].astype(int)                                               # convert string to int\r\n",
							"  return df"
						],
						"outputs": [],
						"execution_count": 593
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Azure database connection string"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": true,
								"outputs_hidden": true
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# credentials\r\n",
							"jdbcHostname = \"srv-db-sql-dmd.database.windows.net\"\r\n",
							"jdbcDatabase = \"db-sql-dmd\"\r\n",
							"jdbcPort = \"1433\"\r\n",
							"username = \"marko\"\r\n",
							"password = \"5Avramovic!\"\r\n",
							"jdbcUrl = \"jdbc:sqlserver://{0}:{1};database={2}\".format(jdbcHostname, jdbcPort, jdbcDatabase)\r\n",
							"connectionProperties = {\r\n",
							"    \"user\" : username,\r\n",
							"    \"password\" : password,\r\n",
							"    \"driver\" : \"com.microsoft.sqlserver.jdbc.SQLServerDriver\"\r\n",
							"}"
						],
						"outputs": [],
						"execution_count": 594
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Create arima function"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def arima(df):\r\n",
							"    n = 30\r\n",
							"    order = [28,0,0]\r\n",
							"    order = [3,0,0]\r\n",
							"    model = ARIMA(df, order=(order))\r\n",
							"    model_fit = model.fit()\r\n",
							"    prediction = model_fit.forecast(n)\r\n",
							"\r\n",
							"    # korekcije\r\n",
							"    prediction = prediction.clip(lower=0)                           # sve negativne vrednosti svedi na 0\r\n",
							"    prediction = add_all_date(prediction)                           # set sundey to 0\r\n",
							"    prediction = prediction.rename(columns={'predicted_mean': item})        # set the name of column as item\r\n",
							"    prediction.head()\r\n",
							"\r\n",
							"    # ako prediction_contaier ne postoji kreiraj ga od prve predikcije, u suprotnom dodaj novu predikciju na prediction_contaier\r\n",
							"    if 'prediction_contaier' not in globals():  \r\n",
							"        # print('not exist')   \r\n",
							"        global prediction_contaier          \r\n",
							"        prediction_contaier = prediction\r\n",
							"    else:\r\n",
							"        # print('exist')             \r\n",
							"        prediction_contaier =  prediction_contaier.join(prediction, how='left', lsuffix='_left', rsuffix='_right')\r\n",
							"    return prediction_contaier"
						],
						"outputs": [],
						"execution_count": 595
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Create import dataset total function"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def import_ds_total(item, brend, table):\r\n",
							"    pushdown_query = \"(SELECT DATUM, {0} FROM {2} ) {1}\".format(item,brend,table) \r\n",
							"    df_spark = spark.read.jdbc(url=jdbcUrl, table=pushdown_query, properties=connectionProperties)\r\n",
							"    df = df_spark.toPandas()                      # Spark df to Pandas df\r\n",
							"\r\n",
							"    df.set_index('DATUM', inplace=True)           # convert DATUM column to index\r\n",
							"    df.index = pd.to_datetime(df.index)           # convert index to datetime\r\n",
							"    df = add_all_date(df, )                       # add all missing date with (df, 0) or without (df, 1) sunday\r\n",
							"    df.head(2)\r\n",
							"    return df \r\n",
							""
						],
						"outputs": [],
						"execution_count": 596
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Train ARIMA model and prediction"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": true,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# n = 19\r\n",
							"# order = [28,0,0]\r\n",
							"# order = [3,0,0]\r\n",
							"# model = ARIMA(df, order=(order))\r\n",
							"# model_fit = model.fit()\r\n",
							"# prediction = model_fit.forecast(n)\r\n",
							"\r\n",
							"# # korekcije\r\n",
							"# prediction = prediction.clip(lower=0)                           # sve negativne vrednosti svedi na 0\r\n",
							"# prediction = add_all_date(prediction)                           # set sundey to 0\r\n",
							"# prediction = prediction.rename(columns={'predicted_mean': item})        # set the name of column as item\r\n",
							"# prediction.head()\r\n",
							"\r\n",
							"# # ako prediction_contaier ne postoji kreiraj ga od prve predikcije, u suprotnom dodaj novu predikciju na prediction_contaier\r\n",
							"# if 'prediction_contaier' not in locals():               \r\n",
							"#     prediction_contaier = prediction\r\n",
							"# else:\r\n",
							"#     prediction_contaier = prediction_contaier.join(prediction, how='left', lsuffix='_left', rsuffix='_right')\r\n",
							"# prediction_contaier.head()"
						],
						"outputs": [],
						"execution_count": 597
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Delete prediction_container"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"if 'prediction_contaier' in globals(): \r\n",
							"    del prediction_contaier\r\n",
							"    print('deleted')"
						],
						"outputs": [],
						"execution_count": 598
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Loop brends - import dataset and applay arima (using custom function)"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# connect to database with credentials, execut SQL \r\n",
							"# STAVKE_NA_KOMIS_NALOGU, KOMIS_NALOG, POVRAT_KARTON, POVRAT_KOMAD,  komisionAggFinal,  povratAggFinal\r\n",
							"item = 'STAVKE_NA_KOMIS_NALOGU'\r\n",
							"brend = 'Grupno'\r\n",
							"table = 'src.komisionAggFinal'\r\n",
							"df = import_ds_total(item, brend, table)\r\n",
							"\r\n",
							"# call arima function on dataset\r\n",
							"prediction_contaier = arima(df)\r\n",
							"prediction_contaier.head(2)"
						],
						"outputs": [],
						"execution_count": 599
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# connect to database with credentials, execut SQL \r\n",
							"item = 'KOMIS_NALOG'\r\n",
							"brend = 'Grupno'\r\n",
							"table = 'src.komisionAggFinal'\r\n",
							"df = import_ds_total(item, brend, table)\r\n",
							"\r\n",
							"# call custom arima function on dataset\r\n",
							"prediction_contaier = arima(df)\r\n",
							"prediction_contaier.head(2)"
						],
						"outputs": [],
						"execution_count": 600
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# connect to database with credentials, execut SQL \r\n",
							"item = 'POVRAT_KARTON'\r\n",
							"brend = 'Grupno'\r\n",
							"table = 'src.povratAggFinal'\r\n",
							"df = import_ds_total(item, brend, table)\r\n",
							"\r\n",
							"# call arima function on dataset\r\n",
							"prediction_contaier = arima(df)\r\n",
							"prediction_contaier.head(2)"
						],
						"outputs": [],
						"execution_count": 601
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# connect to database with credentials, execut SQL \r\n",
							"item = 'POVRAT_KOMAD'\r\n",
							"brend = 'Grupno'\r\n",
							"table = 'src.povratAggFinal'\r\n",
							"df = import_ds_total(item, brend, table)\r\n",
							"\r\n",
							"# call arima function on dataset\r\n",
							"prediction_contaier = arima(df)\r\n",
							"prediction_contaier.head(2)"
						],
						"outputs": [],
						"execution_count": 602
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Covert prediction_contaier index to column and store on blob storage"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# covert index to column\r\n",
							"prediction_contaier['DATUM'] = prediction_contaier.index                      \r\n",
							"# sat DATUM column to be first\r\n",
							"column_name = list(prediction_contaier.columns.values)\r\n",
							"column_name_wo_datum = column_name\r\n",
							"column_name_wo_datum.remove('DATUM')\r\n",
							"prediction_contaier = prediction_contaier[['DATUM'] + column_name_wo_datum]\r\n",
							"prediction_contaier.head()\r\n",
							"\r\n",
							"\r\n",
							"# Output using Spark\r\n",
							"folder_name = brend\r\n",
							"(sqlContext.createDataFrame(prediction_contaier)\r\n",
							" .coalesce(1)\r\n",
							" .write\r\n",
							" .mode(\"overwrite\")\r\n",
							" .option(\"header\", \"true\")\r\n",
							" .format(\"com.databricks.spark.csv\")\r\n",
							" .save('abfss://processed@dlsynapsedts.dfs.core.windows.net/dmd/' + folder_name))"
						],
						"outputs": [],
						"execution_count": 603
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Graph"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# pyplot.figure(figsize=(18, 6), dpi=80)       # adjust graph size\r\n",
							"# pyplot.plot(prediction, color='red', label='prediction')\r\n",
							"# pyplot.legend(loc=\"upper left\")\r\n",
							"# pyplot.show()"
						],
						"outputs": [],
						"execution_count": 604
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SparkSmall')]",
			"type": "Microsoft.Synapse/workspaces/bigDataPools",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"autoPause": {
					"enabled": true,
					"delayInMinutes": 15
				},
				"autoScale": {
					"enabled": true,
					"maxNodeCount": 10,
					"minNodeCount": 3
				},
				"nodeCount": 10,
				"nodeSize": "Small",
				"nodeSizeFamily": "MemoryOptimized",
				"sparkVersion": "3.1",
				"isComputeIsolationEnabled": false,
				"sessionLevelPackagesEnabled": true,
				"annotations": []
			},
			"dependsOn": [],
			"location": "westeurope"
		},
		{
			"name": "[concat(parameters('workspaceName'), '/default')]",
			"type": "Microsoft.Synapse/workspaces/managedVirtualNetworks",
			"apiVersion": "2019-06-01-preview",
			"properties": {},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/default/synapse-ws-sql--synapsedtsws')]",
			"type": "Microsoft.Synapse/workspaces/managedVirtualNetworks/managedPrivateEndpoints",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"privateLinkResourceId": "/subscriptions/3d1a0d9a-7e0f-434a-bb08-b3b842299587/resourceGroups/Synapse_Analytics/providers/Microsoft.Synapse/workspaces/synapsedtsws",
				"groupId": "sql",
				"fqdns": [
					"synapsedtsws.7fef4202-f825-4c26-829b-af5c2e2a7226.sql.azuresynapse.net"
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/managedVirtualNetworks/default')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/default/synapse-ws-sqlOnDemand--synapsedtsws')]",
			"type": "Microsoft.Synapse/workspaces/managedVirtualNetworks/managedPrivateEndpoints",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"privateLinkResourceId": "/subscriptions/3d1a0d9a-7e0f-434a-bb08-b3b842299587/resourceGroups/Synapse_Analytics/providers/Microsoft.Synapse/workspaces/synapsedtsws",
				"groupId": "sqlOnDemand",
				"fqdns": [
					"synapsedtsws-ondemand.7fef4202-f825-4c26-829b-af5c2e2a7226.sql.azuresynapse.net"
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/managedVirtualNetworks/default')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/test_data')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_asa_dts",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "NF-UQ-NIDS-v2_11.csv",
						"folderPath": "dmd/test",
						"fileSystem": "row"
					},
					"columnDelimiter": ",",
					"rowDelimiter": "\n",
					"escapeChar": "\"",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "IPV4_SRC_ADDR",
						"type": "String"
					},
					{
						"name": "L4_SRC_PORT",
						"type": "String"
					},
					{
						"name": "IPV4_DST_ADDR",
						"type": "String"
					},
					{
						"name": "L4_DST_PORT",
						"type": "String"
					},
					{
						"name": "PROTOCOL",
						"type": "String"
					},
					{
						"name": "L7_PROTO",
						"type": "String"
					},
					{
						"name": "IN_BYTES",
						"type": "String"
					},
					{
						"name": "IN_PKTS",
						"type": "String"
					},
					{
						"name": "OUT_BYTES",
						"type": "String"
					},
					{
						"name": "OUT_PKTS",
						"type": "String"
					},
					{
						"name": "TCP_FLAGS",
						"type": "String"
					},
					{
						"name": "CLIENT_TCP_FLAGS",
						"type": "String"
					},
					{
						"name": "SERVER_TCP_FLAGS",
						"type": "String"
					},
					{
						"name": "FLOW_DURATION_MILLISECONDS",
						"type": "String"
					},
					{
						"name": "DURATION_IN",
						"type": "String"
					},
					{
						"name": "DURATION_OUT",
						"type": "String"
					},
					{
						"name": "MIN_TTL",
						"type": "String"
					},
					{
						"name": "MAX_TTL",
						"type": "String"
					},
					{
						"name": "LONGEST_FLOW_PKT",
						"type": "String"
					},
					{
						"name": "SHORTEST_FLOW_PKT",
						"type": "String"
					},
					{
						"name": "MIN_IP_PKT_LEN",
						"type": "String"
					},
					{
						"name": "MAX_IP_PKT_LEN",
						"type": "String"
					},
					{
						"name": "SRC_TO_DST_SECOND_BYTES",
						"type": "String"
					},
					{
						"name": "DST_TO_SRC_SECOND_BYTES",
						"type": "String"
					},
					{
						"name": "RETRANSMITTED_IN_BYTES",
						"type": "String"
					},
					{
						"name": "RETRANSMITTED_IN_PKTS",
						"type": "String"
					},
					{
						"name": "RETRANSMITTED_OUT_BYTES",
						"type": "String"
					},
					{
						"name": "RETRANSMITTED_OUT_PKTS",
						"type": "String"
					},
					{
						"name": "SRC_TO_DST_AVG_THROUGHPUT",
						"type": "String"
					},
					{
						"name": "DST_TO_SRC_AVG_THROUGHPUT",
						"type": "String"
					},
					{
						"name": "NUM_PKTS_UP_TO_128_BYTES",
						"type": "String"
					},
					{
						"name": "NUM_PKTS_128_TO_256_BYTES",
						"type": "String"
					},
					{
						"name": "NUM_PKTS_256_TO_512_BYTES",
						"type": "String"
					},
					{
						"name": "NUM_PKTS_512_TO_1024_BYTES",
						"type": "String"
					},
					{
						"name": "NUM_PKTS_1024_TO_1514_BYTES",
						"type": "String"
					},
					{
						"name": "TCP_WIN_MAX_IN",
						"type": "String"
					},
					{
						"name": "TCP_WIN_MAX_OUT",
						"type": "String"
					},
					{
						"name": "ICMP_TYPE",
						"type": "String"
					},
					{
						"name": "ICMP_IPV4_TYPE",
						"type": "String"
					},
					{
						"name": "DNS_QUERY_ID",
						"type": "String"
					},
					{
						"name": "DNS_QUERY_TYPE",
						"type": "String"
					},
					{
						"name": "DNS_TTL_ANSWER",
						"type": "String"
					},
					{
						"name": "FTP_COMMAND_RET_CODE",
						"type": "String"
					},
					{
						"name": "Label",
						"type": "String"
					},
					{
						"name": "Attack",
						"type": "String"
					},
					{
						"name": "Dataset",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_asa_dts')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL script 1')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'https://dlsynapsedts.dfs.core.windows.net/row/dmd/test/NF-UQ-NIDS-v2_11.csv',\n        FORMAT = 'CSV',\n        HEADER_ROW = TRUE,\nâ¯â¯â¯â¯â¯â¯â¯â¯PARSER_VERSION = '2.0'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL script 2')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    count(*)\nFROM\n    OPENROWSET(\n        BULK 'https://dlsynapsedts.dfs.core.windows.net/row/dmd/test/NF-UQ-NIDS-v2_11.csv',\n        FORMAT = 'CSV',\nâ¯â¯â¯â¯â¯â¯â¯â¯PARSER_VERSION = '2.0'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_test_data_csv_dedicated')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Copy data from csv to dedicated pool",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "SqlPoolSink",
								"allowCopyCommand": true,
								"copyCommandSettings": {},
								"tableOption": "autoCreate"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "IPV4_SRC_ADDR",
											"type": "String"
										},
										"sink": {
											"name": "IPV4_SRC_ADDR",
											"type": "String"
										}
									},
									{
										"source": {
											"name": "L4_SRC_PORT",
											"type": "String"
										},
										"sink": {
											"name": "L4_SRC_PORT",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "IPV4_DST_ADDR",
											"type": "String"
										},
										"sink": {
											"name": "IPV4_DST_ADDR",
											"type": "String"
										}
									},
									{
										"source": {
											"name": "L4_DST_PORT",
											"type": "String"
										},
										"sink": {
											"name": "L4_DST_PORT",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "PROTOCOL",
											"type": "String"
										},
										"sink": {
											"name": "PROTOCOL",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "L7_PROTO",
											"type": "String"
										},
										"sink": {
											"name": "L7_PROTO",
											"type": "Single"
										}
									},
									{
										"source": {
											"name": "IN_BYTES",
											"type": "String"
										},
										"sink": {
											"name": "IN_BYTES",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "IN_PKTS",
											"type": "String"
										},
										"sink": {
											"name": "IN_PKTS",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "OUT_BYTES",
											"type": "String"
										},
										"sink": {
											"name": "OUT_BYTES",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "OUT_PKTS",
											"type": "String"
										},
										"sink": {
											"name": "OUT_PKTS",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "TCP_FLAGS",
											"type": "String"
										},
										"sink": {
											"name": "TCP_FLAGS",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "CLIENT_TCP_FLAGS",
											"type": "String"
										},
										"sink": {
											"name": "CLIENT_TCP_FLAGS",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "SERVER_TCP_FLAGS",
											"type": "String"
										},
										"sink": {
											"name": "SERVER_TCP_FLAGS",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "FLOW_DURATION_MILLISECONDS",
											"type": "String"
										},
										"sink": {
											"name": "FLOW_DURATION_MILLISECONDS",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "DURATION_IN",
											"type": "String"
										},
										"sink": {
											"name": "DURATION_IN",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "DURATION_OUT",
											"type": "String"
										},
										"sink": {
											"name": "DURATION_OUT",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "MIN_TTL",
											"type": "String"
										},
										"sink": {
											"name": "MIN_TTL",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "MAX_TTL",
											"type": "String"
										},
										"sink": {
											"name": "MAX_TTL",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "LONGEST_FLOW_PKT",
											"type": "String"
										},
										"sink": {
											"name": "LONGEST_FLOW_PKT",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "SHORTEST_FLOW_PKT",
											"type": "String"
										},
										"sink": {
											"name": "SHORTEST_FLOW_PKT",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "MIN_IP_PKT_LEN",
											"type": "String"
										},
										"sink": {
											"name": "MIN_IP_PKT_LEN",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "MAX_IP_PKT_LEN",
											"type": "String"
										},
										"sink": {
											"name": "MAX_IP_PKT_LEN",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "SRC_TO_DST_SECOND_BYTES",
											"type": "String"
										},
										"sink": {
											"name": "SRC_TO_DST_SECOND_BYTES",
											"type": "Single"
										}
									},
									{
										"source": {
											"name": "DST_TO_SRC_SECOND_BYTES",
											"type": "String"
										},
										"sink": {
											"name": "DST_TO_SRC_SECOND_BYTES",
											"type": "Single"
										}
									},
									{
										"source": {
											"name": "RETRANSMITTED_IN_BYTES",
											"type": "String"
										},
										"sink": {
											"name": "RETRANSMITTED_IN_BYTES",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "RETRANSMITTED_IN_PKTS",
											"type": "String"
										},
										"sink": {
											"name": "RETRANSMITTED_IN_PKTS",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "RETRANSMITTED_OUT_BYTES",
											"type": "String"
										},
										"sink": {
											"name": "RETRANSMITTED_OUT_BYTES",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "RETRANSMITTED_OUT_PKTS",
											"type": "String"
										},
										"sink": {
											"name": "RETRANSMITTED_OUT_PKTS",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "SRC_TO_DST_AVG_THROUGHPUT",
											"type": "String"
										},
										"sink": {
											"name": "SRC_TO_DST_AVG_THROUGHPUT",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "DST_TO_SRC_AVG_THROUGHPUT",
											"type": "String"
										},
										"sink": {
											"name": "DST_TO_SRC_AVG_THROUGHPUT",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "NUM_PKTS_UP_TO_128_BYTES",
											"type": "String"
										},
										"sink": {
											"name": "NUM_PKTS_UP_TO_128_BYTES",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "NUM_PKTS_128_TO_256_BYTES",
											"type": "String"
										},
										"sink": {
											"name": "NUM_PKTS_128_TO_256_BYTES",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "NUM_PKTS_256_TO_512_BYTES",
											"type": "String"
										},
										"sink": {
											"name": "NUM_PKTS_256_TO_512_BYTES",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "NUM_PKTS_512_TO_1024_BYTES",
											"type": "String"
										},
										"sink": {
											"name": "NUM_PKTS_512_TO_1024_BYTES",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "NUM_PKTS_1024_TO_1514_BYTES",
											"type": "String"
										},
										"sink": {
											"name": "NUM_PKTS_1024_TO_1514_BYTES",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "TCP_WIN_MAX_IN",
											"type": "String"
										},
										"sink": {
											"name": "TCP_WIN_MAX_IN",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "TCP_WIN_MAX_OUT",
											"type": "String"
										},
										"sink": {
											"name": "TCP_WIN_MAX_OUT",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "ICMP_TYPE",
											"type": "String"
										},
										"sink": {
											"name": "ICMP_TYPE",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "ICMP_IPV4_TYPE",
											"type": "String"
										},
										"sink": {
											"name": "ICMP_IPV4_TYPE",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "DNS_QUERY_ID",
											"type": "String"
										},
										"sink": {
											"name": "DNS_QUERY_ID",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "DNS_QUERY_TYPE",
											"type": "String"
										},
										"sink": {
											"name": "DNS_QUERY_TYPE",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "DNS_TTL_ANSWER",
											"type": "String"
										},
										"sink": {
											"name": "DNS_TTL_ANSWER",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "FTP_COMMAND_RET_CODE",
											"type": "String"
										},
										"sink": {
											"name": "FTP_COMMAND_RET_CODE",
											"type": "Single"
										}
									},
									{
										"source": {
											"name": "Label",
											"type": "String"
										},
										"sink": {
											"name": "LABEL_1",
											"type": "Int64"
										}
									},
									{
										"source": {
											"name": "Attack",
											"type": "String"
										},
										"sink": {
											"name": "ATTACK",
											"type": "String"
										}
									},
									{
										"source": {
											"name": "Dataset\r",
											"type": "String"
										},
										"sink": {
											"name": "DATASET",
											"type": "String"
										}
									}
								]
							}
						},
						"inputs": [
							{
								"referenceName": "test_data",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_SqlPoolTable1",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/test_data')]",
				"[concat(variables('workspaceId'), '/datasets/ds_SqlPoolTable1')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/smallPoolDed')]",
			"type": "Microsoft.Synapse/workspaces/sqlPools",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_SqlPoolTable1')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "SqlPoolTable",
				"schema": [],
				"typeProperties": {
					"schema": "test",
					"table": "datatest"
				},
				"sqlPool": {
					"referenceName": "smallPoolDed",
					"type": "SqlPoolReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/sqlPools/smallPoolDed')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_test_data_csv_sql')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Copy data from csv to dedicated pool",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "IPV4_SRC_ADDR",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "IPV4_SRC_ADDR",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "L4_SRC_PORT",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "L4_SRC_PORT",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "IPV4_DST_ADDR",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "IPV4_DST_ADDR",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "L4_DST_PORT",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "L4_DST_PORT",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "PROTOCOL",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PROTOCOL",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "L7_PROTO",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "L7_PROTO",
											"type": "Double",
											"physicalType": "float"
										}
									},
									{
										"source": {
											"name": "IN_BYTES",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "IN_BYTES",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "IN_PKTS",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "IN_PKTS",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "OUT_BYTES",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OUT_BYTES",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "OUT_PKTS",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OUT_PKTS",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "TCP_FLAGS",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "TCP_FLAGS",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "CLIENT_TCP_FLAGS",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CLIENT_TCP_FLAGS",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "SERVER_TCP_FLAGS",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SERVER_TCP_FLAGS",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "FLOW_DURATION_MILLISECONDS",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "FLOW_DURATION_MILLISECONDS",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "DURATION_IN",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DURATION_IN",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "DURATION_OUT",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DURATION_OUT",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "MIN_TTL",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MIN_TTL",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "MAX_TTL",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MAX_TTL",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "LONGEST_FLOW_PKT",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "LONGEST_FLOW_PKT",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "SHORTEST_FLOW_PKT",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SHORTEST_FLOW_PKT",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "MIN_IP_PKT_LEN",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MIN_IP_PKT_LEN",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "MAX_IP_PKT_LEN",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MAX_IP_PKT_LEN",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "SRC_TO_DST_SECOND_BYTES",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SRC_TO_DST_SECOND_BYTES",
											"type": "Double",
											"physicalType": "float"
										}
									},
									{
										"source": {
											"name": "DST_TO_SRC_SECOND_BYTES",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DST_TO_SRC_SECOND_BYTES",
											"type": "Double",
											"physicalType": "float"
										}
									},
									{
										"source": {
											"name": "RETRANSMITTED_IN_BYTES",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "RETRANSMITTED_IN_BYTES",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "RETRANSMITTED_IN_PKTS",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "RETRANSMITTED_IN_PKTS",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "RETRANSMITTED_OUT_BYTES",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "RETRANSMITTED_OUT_BYTES",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "RETRANSMITTED_OUT_PKTS",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "RETRANSMITTED_OUT_PKTS",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "SRC_TO_DST_AVG_THROUGHPUT",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SRC_TO_DST_AVG_THROUGHPUT",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "DST_TO_SRC_AVG_THROUGHPUT",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DST_TO_SRC_AVG_THROUGHPUT",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "NUM_PKTS_UP_TO_128_BYTES",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "NUM_PKTS_UP_TO_128_BYTES",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "NUM_PKTS_128_TO_256_BYTES",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "NUM_PKTS_128_TO_256_BYTES",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "NUM_PKTS_256_TO_512_BYTES",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "NUM_PKTS_256_TO_512_BYTES",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "NUM_PKTS_512_TO_1024_BYTES",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "NUM_PKTS_512_TO_1024_BYTES",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "NUM_PKTS_1024_TO_1514_BYTES",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "NUM_PKTS_1024_TO_1514_BYTES",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "TCP_WIN_MAX_IN",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "TCP_WIN_MAX_IN",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "TCP_WIN_MAX_OUT",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "TCP_WIN_MAX_OUT",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "ICMP_TYPE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ICMP_TYPE",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "ICMP_IPV4_TYPE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ICMP_IPV4_TYPE",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "DNS_QUERY_ID",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DNS_QUERY_ID",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "DNS_QUERY_TYPE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DNS_QUERY_TYPE",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "DNS_TTL_ANSWER",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DNS_TTL_ANSWER",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "FTP_COMMAND_RET_CODE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "FTP_COMMAND_RET_CODE",
											"type": "Double",
											"physicalType": "float"
										}
									},
									{
										"source": {
											"name": "Label",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "LABEL_1",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "Attack",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ATTACK",
											"type": "String",
											"physicalType": "varchar"
										}
									},
									{
										"source": {
											"name": "Dataset\r",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DATASET",
											"type": "String",
											"physicalType": "varchar"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "test_data",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_sql_test_dataset",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/test_data')]",
				"[concat(variables('workspaceId'), '/datasets/ds_sql_test_dataset')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_sql_test_dataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_asql_db",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "IPV4_SRC_ADDR",
						"type": "varchar"
					},
					{
						"name": "L4_SRC_PORT",
						"type": "int",
						"precision": 10
					},
					{
						"name": "IPV4_DST_ADDR",
						"type": "varchar"
					},
					{
						"name": "L4_DST_PORT",
						"type": "int",
						"precision": 10
					},
					{
						"name": "PROTOCOL",
						"type": "int",
						"precision": 10
					},
					{
						"name": "L7_PROTO",
						"type": "float",
						"precision": 15
					},
					{
						"name": "IN_BYTES",
						"type": "int",
						"precision": 10
					},
					{
						"name": "IN_PKTS",
						"type": "int",
						"precision": 10
					},
					{
						"name": "OUT_BYTES",
						"type": "int",
						"precision": 10
					},
					{
						"name": "OUT_PKTS",
						"type": "int",
						"precision": 10
					},
					{
						"name": "TCP_FLAGS",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CLIENT_TCP_FLAGS",
						"type": "int",
						"precision": 10
					},
					{
						"name": "SERVER_TCP_FLAGS",
						"type": "int",
						"precision": 10
					},
					{
						"name": "FLOW_DURATION_MILLISECONDS",
						"type": "int",
						"precision": 10
					},
					{
						"name": "DURATION_IN",
						"type": "int",
						"precision": 10
					},
					{
						"name": "DURATION_OUT",
						"type": "int",
						"precision": 10
					},
					{
						"name": "MIN_TTL",
						"type": "int",
						"precision": 10
					},
					{
						"name": "MAX_TTL",
						"type": "int",
						"precision": 10
					},
					{
						"name": "LONGEST_FLOW_PKT",
						"type": "int",
						"precision": 10
					},
					{
						"name": "SHORTEST_FLOW_PKT",
						"type": "int",
						"precision": 10
					},
					{
						"name": "MIN_IP_PKT_LEN",
						"type": "int",
						"precision": 10
					},
					{
						"name": "MAX_IP_PKT_LEN",
						"type": "int",
						"precision": 10
					},
					{
						"name": "SRC_TO_DST_SECOND_BYTES",
						"type": "float",
						"precision": 15
					},
					{
						"name": "DST_TO_SRC_SECOND_BYTES",
						"type": "float",
						"precision": 15
					},
					{
						"name": "RETRANSMITTED_IN_BYTES",
						"type": "int",
						"precision": 10
					},
					{
						"name": "RETRANSMITTED_IN_PKTS",
						"type": "int",
						"precision": 10
					},
					{
						"name": "RETRANSMITTED_OUT_BYTES",
						"type": "int",
						"precision": 10
					},
					{
						"name": "RETRANSMITTED_OUT_PKTS",
						"type": "int",
						"precision": 10
					},
					{
						"name": "SRC_TO_DST_AVG_THROUGHPUT",
						"type": "int",
						"precision": 10
					},
					{
						"name": "DST_TO_SRC_AVG_THROUGHPUT",
						"type": "int",
						"precision": 10
					},
					{
						"name": "NUM_PKTS_UP_TO_128_BYTES",
						"type": "int",
						"precision": 10
					},
					{
						"name": "NUM_PKTS_128_TO_256_BYTES",
						"type": "int",
						"precision": 10
					},
					{
						"name": "NUM_PKTS_256_TO_512_BYTES",
						"type": "int",
						"precision": 10
					},
					{
						"name": "NUM_PKTS_512_TO_1024_BYTES",
						"type": "int",
						"precision": 10
					},
					{
						"name": "NUM_PKTS_1024_TO_1514_BYTES",
						"type": "int",
						"precision": 10
					},
					{
						"name": "TCP_WIN_MAX_IN",
						"type": "int",
						"precision": 10
					},
					{
						"name": "TCP_WIN_MAX_OUT",
						"type": "int",
						"precision": 10
					},
					{
						"name": "ICMP_TYPE",
						"type": "int",
						"precision": 10
					},
					{
						"name": "ICMP_IPV4_TYPE",
						"type": "int",
						"precision": 10
					},
					{
						"name": "DNS_QUERY_ID",
						"type": "int",
						"precision": 10
					},
					{
						"name": "DNS_QUERY_TYPE",
						"type": "int",
						"precision": 10
					},
					{
						"name": "DNS_TTL_ANSWER",
						"type": "int",
						"precision": 10
					},
					{
						"name": "FTP_COMMAND_RET_CODE",
						"type": "float",
						"precision": 15
					},
					{
						"name": "LABEL_1",
						"type": "int",
						"precision": 10
					},
					{
						"name": "ATTACK",
						"type": "varchar"
					},
					{
						"name": "DATASET",
						"type": "varchar"
					}
				],
				"typeProperties": {
					"schema": "test",
					"table": "datatest"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_asql_db')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_store_Classic_test')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Stored procedure1 to dedicated pool",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[dbo].[proceduraTest]"
						},
						"linkedServiceName": {
							"referenceName": "synapsedtsws-WorkspaceDefaultSqlServer",
							"type": "LinkedServiceReference",
							"parameters": {
								"DBName": "smallPoolDed"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/synapsedtsws-WorkspaceDefaultSqlServer')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pip_store_proced_SQL_pool')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "SQL pool stored procedure1 test dedicted pool",
						"type": "SqlPoolStoredProcedure",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"sqlPool": {
							"referenceName": "smallPoolDed",
							"type": "SqlPoolReference"
						},
						"typeProperties": {
							"storedProcedureName": "[dbo].[proceduraTest]"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/sqlPools/smallPoolDed')]"
			]
		}
	]
}